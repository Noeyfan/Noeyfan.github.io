<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: interview | NOEY]]></title>
  <link href="http://fyou.me/blog/categories/interview/atom.xml" rel="self"/>
  <link href="http://fyou.me/"/>
  <updated>2018-04-01T19:56:54-07:00</updated>
  <id>http://fyou.me/</id>
  <author>
    <name><![CDATA[Fan You]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[5. Kth Largest Element (快排之思)]]></title>
    <link href="http://fyou.me/blog/2018/04/01/5-kth-largest-element/"/>
    <updated>2018-04-01T14:23:39-07:00</updated>
    <id>http://fyou.me/blog/2018/04/01/5-kth-largest-element</id>
    <content type="html"><![CDATA[<p>起因源于我与同事争论，find kth largest element是O(n)的复杂度还是O(nlogn) 。我一直认为find kth largest element 最优解与快排同源，所以应该是O(nlogn)，事实证明我是错的，实际的解法是快速选择，O(n)最优情况，O(n<sup>2</sup>)最差情况。</p>

<p>解法都大同小异如下: （我取了中间点作为pivot，最简单的做法是取头或者尾作为pivot）</p>

<pre><code class="c++">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        return find(nums, 0, nums.size()-1, k);
    }

    int partition(vector&lt;int&gt;&amp; nums, int begin, int end, int k)
    {
        if (begin &gt; end) return -1; // should not happend
        int p = nums[(end + begin)/2];
        int i  = begin, j = end;
        while(i != j)
        {
            if (nums[j] &gt; p)
            {
                j--;
            }
            else if (nums[i] &lt; p)
            {
                i++;
            }
            else
            {
                std::swap(nums[i], nums[j]);
                if (nums[j] == p) i++; // edge case where after swap if nums[j] == p then we can't --j
                else j--;
            }
        }
        int diff = end-i+1-k;
        if (diff == 0)
        {
            return nums[i];
        }
        else if (diff &gt; 0)
        {
            return find(nums,i+1,end,k); // i j are the same anyways
        }
        else
        {
            return find(nums,begin,j-1,-diff); // i j are the same anyways
        }
    }
};
</code></pre>

<p>关键在于复杂度的分析。</p>

<h4>快排：</h4>

<p>快排的(average)复杂度之所以为O(nlogn)，因为每次partition需要O(n)，</p>

<p><strong>最差情况：</strong>每次partition正好为<code>[]和[0..n]</code> ，也就是<code>T(n)=T(n-1)+T(0)+O(n) -&gt; T(n)=T(n-1)+O(n)-&gt; T(n)=O(n^2)</code></p>

<p><strong>最优情况：</strong>每次partition正好为<code>[0..n/2-1]和[n/2..n]</code> ，也就是<code>T(n)=2T(n/2)+O(n) -&gt; T(n)=O(nlogn)</code></p>

<p>同时也可以简单理解为最差需要partition O(n)次而最优只需要partition O(logn)次</p>

<h4><strong>快速选择：</strong></h4>

<p>快速选择的(average)复杂度之所以为O(n)，因为每次递归只需要partition整个array的一半，</p>

<p><strong>最差情况：</strong>依旧与快排类似，如果每次pivot都选择了最小或者最大，那么还是需要O(n<sup>2</sup>)去完成整个操作</p>

<p><strong>最优情况：</strong>如果pivot正好选择了中间值，那么<code>T(n)=T(n/2)+O(n) -&gt; T(n)=2O(n) -&gt; T(n)=O(n)</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[427. Generate Parentheses]]></title>
    <link href="http://fyou.me/blog/2018/03/28/427-generate-parentheses/"/>
    <updated>2018-03-28T00:05:47-07:00</updated>
    <id>http://fyou.me/blog/2018/03/28/427-generate-parentheses</id>
    <content type="html"><![CDATA[<p><a href="http://www.lintcode.com/en/problem/generate-parentheses/">http://www.lintcode.com/en/problem/generate-parentheses/</a></p>

<p>这道题给定n，然后输出所有长度为2n的valid parentheses.</p>

<p><strong>解法一：</strong></p>

<p>最简单的解法是枚举，用两个变量num_of_left, num_of_right去track还有多少个左括号和右括号可以使用。只要有左括号可以用就可以继续递归generate，但是只有可用右括号大于左括号时候才可以继续递归generate，防止&#8221;)(&ldquo;的情况。</p>

<pre><code class="c++">class Solution {
public:
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;string&gt; ret;
        generate(ret, "", n, n);
        return ret;
    }

    void generate(
        vector&lt;string&gt;&amp; ret,
        string s,
        int num_of_left,
        int num_of_right)
    {
        if (num_of_left == 0 &amp;&amp; num_of_right == 0)
        {
            ret.push_back(s);
            return;
        }

        if (num_of_left &gt; 0)
        {
            generate(ret, s+"(", num_of_left-1, num_of_right);
        }
        if (num_of_right &gt; num_of_left)
        {
            generate(ret, s+")", num_of_left, num_of_right-1);
        }
    }
};
</code></pre>

<p><strong>解法二：</strong></p>

<p>dp的思路 ，想求第f(n)，就是将&#8221;()&ldquo;加入f(n-1)的结果：</p>

<p>f(0): &ldquo;&rdquo;</p>

<p>f(1): &ldquo;(&#8220;f(0)&rdquo;)&#8221;</p>

<p>f(2): &ldquo;(&#8220;f(0)&rdquo;)&ldquo;f(1), &rdquo;(&ldquo;f(1)&rdquo;)&#8221;</p>

<p>f(3): &ldquo;(&#8220;f(0)&rdquo;)&ldquo;f(2), &rdquo;(&ldquo;f(1)&rdquo;)&ldquo;f(1), &rdquo;(&ldquo;f(2)&rdquo;)&#8221;</p>

<p>所以 f(n) = &ldquo;(&#8220;f(0)&rdquo;)&ldquo;f(n-1) , &rdquo;(&ldquo;f(1)&rdquo;)&ldquo;f(n-2) &rdquo;(&ldquo;f(2)&rdquo;)&ldquo;f(n-3) … &rdquo;(&ldquo;f(i)&rdquo;)&ldquo;f(n-1-i) … &rdquo;(f(n-1)&ldquo;)&rdquo;</p>

<pre><code class="c++">class Solution {
public:
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;vector&lt;string&gt;&gt; tmp = ;
        for (int j = 1; j &lt;= n; ++j)
        {
            vector&lt;string&gt; vec;
            for (int i = 0; i &lt; j; ++i)
            {
                for (auto fst : tmp[i])
                {
                    for (auto snd : tmp[j-i-1])
                    {
                        vec.push_back("("+fst+")"+snd);
                    }
                }
            }
            tmp.push_back(vec);
        }
        return tmp.back();
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[919. Meeting Rooms II]]></title>
    <link href="http://fyou.me/blog/2018/03/21/919-meeting-rooms-ii/"/>
    <updated>2018-03-21T22:24:39-07:00</updated>
    <id>http://fyou.me/blog/2018/03/21/919-meeting-rooms-ii</id>
    <content type="html"><![CDATA[<p>考察Interval intersection, 一次遍历内解决问题和多维数组一直是我的弱项。</p>

<h4>920. <a href="http://www.lintcode.com/en/problem/meeting-rooms/">Meeting Rooms</a></h4>

<p>这道题给一个Interval list只考察Interval有无交集，所以从第二个element开始，只要test自己的start是否小于前一个Interval的end。(前提：List以Interval start sorted)</p>

<pre><code class="c++">class Solution {
public:
    bool canAttendMeetings(vector&lt;Interval&gt; &amp;intervals) {
        if (intervals.size() &lt;= 1) return true;
        sort(
            intervals.begin(),
            intervals.end(),
            [](const Interval &amp;a, const Interval &amp;b)
            {
                return a.start &lt; b.start;
            });
        for (int i = 1; i &lt; intervals.size(); ++i)
        {
            if (intervals[i].start &lt; intervals[i-1].end) return false;
        }
        return true;
    }
};
</code></pre>

<h4>919. <a href="http://www.lintcode.com/en/problem/meeting-rooms-ii/">Meeting Rooms II</a></h4>

<p>这道题唯一的区别是要算出在同一时间点，有多少同时进行的meeting，得出需要多少个不同的meeting room。</p>

<p>我的初始想法是将每一个interval的时间点都存入hashmap，然后遍历一遍map，算出最大值。这个解法works，但是耗费了很多空间，大部分的时间点存在hashmap里都毫无意义，唯有start和end才是我们关注的，所以改进的解法是将start和end同时存进一个vector并mark上每个点是start还是end，然后sort这个vector，最后遍历一遍vector，start的点counter++，end的点counter&#8211;，同时track max value。</p>

<pre><code class="c++">class Solution {
public:
    bool START = true;
    bool END = false;

    int minMeetingRooms(vector&lt;Interval&gt; &amp;intervals) {
        vector&lt;pair&lt;int, bool&gt;&gt; vec;
        for (const auto&amp; itv : intervals)
        {
            vec.push_back(make_pair(itv.start, START));
            vec.push_back(make_pair(itv.end, END));
        }

        std::sort(vec.begin(), vec.end(),
        [](const auto&amp; l, const auto&amp; r) {
            return l.first &lt; r.first;
        });

        int rooms = 0, current = 0;
        for (const auto&amp; it : vec)
        {
            if (it.second)
            {
                current++;
            }
            else
            {
                current--;
            }
            rooms = std::max(rooms, current);
        }

        return rooms;
    }
};
</code></pre>

<p>同时在网上看到了两个不错的解法。</p>

<h5>解法一：</h5>

<p>还是使用hashmap，但是只存start和end点的count，最后遍历map，然后sum所有start和end，并且track max value，最后max value就是结果。</p>

<pre><code class="c++">class Solution {
public:
    int minMeetingRooms(vector&lt;Interval&gt;&amp; intervals) {
        map&lt;int, int&gt; m;
        for (auto a : intervals) {
            ++m[a.start];
            --m[a.end];
        }
        int rooms = 0, res = 0;
        for (auto it : m) {
            res = max(res, rooms += it.second);
        }
        return res;
    }
};
</code></pre>

<h5>解法二：</h5>

<p>使用最小堆去track离当前最近的会议结束的时间(last.end)，如果last.end &lt;= cur.start，就表示上一个会议已经结束，可以将其从heap里pop出去，这样我们动态的maintain了一个heap，heap的size就表示当前的会议一共要多少间会议室。</p>

<pre><code class="c++">class Solution {
public:
    int minMeetingRooms(vector&lt;Interval&gt;&amp; intervals) {
        sort(intervals.begin(), intervals.end(), [](const Interval &amp;a, const Interval &amp;b){return a.start &lt; b.start;});
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;
        for (auto a : intervals) {
            if (!q.empty() &amp;&amp; q.top() &lt;= a.start) q.pop();
            q.push(a.end);
        }
        return q.size();
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[736. Parse Lisp Expression]]></title>
    <link href="http://fyou.me/blog/2018/03/11/736-parse-lisp-expression/"/>
    <updated>2018-03-11T21:46:05-07:00</updated>
    <id>http://fyou.me/blog/2018/03/11/736-parse-lisp-expression</id>
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/parse-lisp-expression/description/">https://leetcode.com/problems/parse-lisp-expression/description/</a></p>

<p>(很喜欢leetcode里的这个解法，故此记录一下，不太喜欢的是使用了deque存symbol table，如果直接用map作为递归参数会更好。)</p>

<p>解法用了top-down parsing，用getToken和++pos来consume token，优先处理add/mult的简单情况，然后处理let，逻辑清晰，值得学些。</p>

<pre><code class="c++">class Solution {
public:
    int evaluate(string expression) {
        scopes_.clear();
        int pos = 0;
        return eval(expression, pos);
    }
private:
    int eval(const string&amp; s, int&amp; pos) {
        scopes_.push_front(unordered_map&lt;string, int&gt;());
        int value = 0; // The return value of current expr
        if (s[pos] == '(') ++pos;

        // command, variable or number
        const string token = getToken(s, pos);

        if (token == "add") {
            int v1 = eval(s, ++pos);
            int v2 = eval(s, ++pos);
            value = v1 + v2;
        } else if (token == "mult") {
            int v1 = eval(s, ++pos);
            int v2 = eval(s, ++pos);
            value = v1 * v2;
        } else if (token == "let") {
            string var;
            // expecting " var1 exp1 var2 exp2 ... last_expr)"
            while (s[pos] != ')') {
                ++pos;
                // Must be last_expr
                if (s[pos] == '(') {
                    value = eval(s, ++pos);
                    break;
                }
                // Get a token, could be "x" or "-12" for last_expr
                var = getToken(s, pos);
                // End of let, var is last_expr
                if (s[pos] == ')') {
                    if (isalpha(var[0]))
                        value = getValue(var);
                    else
                        value = stoi(var);
                    break;
                }
                // x -12 -&gt; set x to -12 and store in the current scope and take it as the current return value
                value = scopes_.front()[var] = eval(s, ++pos);
            }
        } else if (isalpha(token[0])) {
            value = getValue(token); // symbol
        } else {
            value = std::stoi(token); // number
        }
        if (s[pos] == ')') ++pos;
        scopes_.pop_front();
        return value;
    }

    int getValue(const string&amp; symbol) {
        for (const auto&amp; scope : scopes_)
            if (scope.count(symbol)) return scope.at(symbol);
        return 0;
    }

    // Get a token from current pos.
    // "let x" -&gt; "let"
    // "-12 (add x y)" -&gt; "-12"
    string getToken(const string&amp; s, int&amp; pos) {
        string token;
        while (pos &lt; s.length()) {
            if (s[pos] == ')' || s[pos] == ' ') break;
            token += s[pos++];
        }
        return token;
    }

    deque&lt;unordered_map&lt;string, int&gt;&gt; scopes_;
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10. Regular Expression Matching]]></title>
    <link href="http://fyou.me/blog/2017/06/07/regex-matching/"/>
    <updated>2017-06-07T01:30:00-07:00</updated>
    <id>http://fyou.me/blog/2017/06/07/regex-matching</id>
    <content type="html"><![CDATA[<p>准备督促自己刷刷题／打打codejam，保持手感，记录一些难倒过自己的题目，从错误开始到正确思路，（也许）包括一些深入的拓展。</p>

<h4>题目</h4>

<p>第一题就从<a href="https://leetcode.com/problems/regular-expression-matching/">Regular Expression Matching</a>开始好了，简言之写个方法:</p>

<pre><code class="c++">bool isMatch(string s, string regex);
</code></pre>

<h4>思路</h4>

<p>超简化的Regular Expression Matching，通常只包含：<code>* . [a-Z]</code>几种元素，所以从简单入手分析所有可能的match情形:</p>

<ul>
<li><code>[a-Z]</code> 和 <code>[a-Z]</code>，属于exact match，只需要关注当前位置</li>
<li><code>[a-Z]</code> 和 <code>.</code>， 属于any match，与上种情况类似，但是<code>\0</code> 和 <code>.</code> 是不能match的</li>
<li><code>[a-Z]</code> 和 <code>([a-Z]|.)*</code>，属于repeat match, 也是这题的唯一难点，有两种情况，且可以用DFS暴力解决：

<ul>
<li><code>*</code> match >=1 次: <code>[a-Z]</code> match <code>[a-Z]|.</code>  &amp;&amp; <code>s+1</code> 也要match <code>regex</code></li>
<li><code>*</code> match 0 次: <code>s</code> match <code>regex+2</code></li>
</ul>
</li>
</ul>


<h4>曾犯错误</h4>

<p>之下都是我在面试或者写题中出现过的错误：</p>

<ul>
<li>与WildCardMatching混淆，认为一个for loop可以解决（非DP）</li>
<li>边界情况 <code>""</code> 与 <code>.*</code>的match</li>
<li>For loop 和DFS 在此处混用，逻辑不清（紧张？？？）</li>
<li>强行用c++ string 进DFS却又不想用index （<code>string::data() -&gt; const char*</code>）</li>
<li>没有处理<code>\0</code> 和 <code>.</code> 的情况</li>
</ul>


<p>不怕笑话，试着回忆一些面试写的丑逼代码：</p>

<h5>丑1:</h5>

<pre><code class="c++">bool isMatch(string s, string regex) {
  if (s.empty() &amp;&amp; regex.empty()) return false;
  int r_i = 0;
  for (int i = 0; i &lt; s.size(); ++i) {
    if (s[i] == regex[r_i]) {
      return isMatch(s.substr(i), regex.substr(r_i));
    }
    if (regex[r_i] == '*') { // should be regex[r_i+1] == '*'
      return isMatch(s.substr(i+1), regex.substr(r_i-1))
        || isMatch(s.substr(i), regex.substr(r_i+1));
    }
    if (regex[r_i] == '.') {
      return isMatch(s.substr(i+1), regex.substr(r_i+1));
    }
    return false;
  }
  return false;
}
</code></pre>

<h5>丑2：</h5>

<pre><code class="c++">bool isMatch(string s, string p) {
  return imp(s.data(), p.data());
}

bool imp(const char* c, const char* p) {
    if (*c == '\0' &amp;&amp; *p == '\0') {
        return true;
    }
    if (*p == '\0' || *c == '\0') return false; // ??? patching
    if (*(p+1) == '*') {
        return isMatch(c+1, p) || isMatch(c+1, p+2); // should be || isMatch(c, p+2)
    }
    if (*c == *p || *p == '.') {  // '\0' and '.'
        return isMatch(c+1, p+1);
    }
    return false;
}
</code></pre>

<h4>正确姿势</h4>

<h5>DFS</h5>

<p>算法清晰的情况下，DFS 解法基本等同于直接翻译：</p>

<pre><code class="c++">bool isMatch(string s, string p) {
  return imp(s.data(), p.data());
}

bool imp(const char* c, const char* p) {
    // only when regex reaches the end, *c check make sense
    if (*p == '\0') return *c == '\0';
    if (*(p+1) == '*') {
        return
          imp(c, p+2)
          // test if c is end of string then we can safely
          // recursively call imp(c+1, p)
          || ((*p == *c || (*c != '\0' &amp;&amp; *p == '.'))
                &amp;&amp; imp(c+1, p));
    }
    if (*c == *p || (*c != '\0' &amp;&amp; *p == '.')) {
        return imp(c+1, p+1);
    }
    return false;
}
</code></pre>

<h5>DP</h5>

<p>DP的关键在于构建状态转移矩阵，而此处构建的方法为：令 <code>bool f[i][j]</code>为 <code>s[i-1]</code> match <code>p[j-1]</code> 的情况，然后写出 <code>f[i][j]</code> 与 <code>p[i-1]</code> <code>j[i-1]</code> 的关系，相同<strong>思路</strong>。</p>

<p>其中初始化<code>f[0][j]</code>要有讲究（也就是<code>empty string</code> 与 什么样的<code>regex</code>算matching）。</p>

<p>详细请看代码注释：</p>

<pre><code class="c++">// Copy from Leetcode
bool isMatch(string s, string p) {
    /**
     * f[i][j]: if s[0..i-1] matches p[0..j-1]
     * if p[j - 1] != '*'
     *      f[i][j] = f[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1]
     * if p[j - 1] == '*', denote p[j - 2] with x
     *      f[i][j] is true iff any of the following is true
     *      1) "x*" repeats 0 time and matches empty: f[i][j - 2]
     *      2) "x*" repeats &gt;= 1 times and matches "x*x": s[i - 1] == x &amp;&amp; f[i - 1][j]
     * '.' matches any single character
     */
    int m = s.size(), n = p.size();
    vector&lt;vector&lt;bool&gt;&gt; f(m + 1, vector&lt;bool&gt;(n + 1, false));

    f[0][0] = true;
    for (int i = 1; i &lt;= m; i++)
        f[i][0] = false;
    // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is '*' 
    // and p[0..j - 3] matches empty
    for (int j = 1; j &lt;= n; j++)
        f[0][j] = j &gt; 1 &amp;&amp; '*' == p[j - 1] &amp;&amp; f[0][j - 2];

    for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt;= n; j++)
            if (p[j - 1] != '*') {
                f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] 
                                              || '.' == p[j - 1]);
            }
            else
                // p[0] cannot be '*' so no need to check "j &gt; 1" here
                f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] 
                                          || '.' == p[j - 2]) &amp;&amp; f[i - 1][j];

    return f[m][n];
}
</code></pre>

<h4>拓展</h4>

<ul>
<li>尝试用NFA解决真正的<code>regex</code>问题，尝试自己土制了一个小 <a href="https://github.com/Noeyfan/noey_algos/blob/master/noey_regex.h">regex lib</a>.</li>
<li>还有Tim的 <a href="https://gist.github.com/Noeyfan/1c60fa6555f6cdc50fd2f55d78aed8a9">compile time regex (no parsing)</a></li>
</ul>


<h4>相似题目</h4>

<p><code>// placeholder，将遇到的相似题目加入此处</code></p>
]]></content>
  </entry>
  
</feed>
