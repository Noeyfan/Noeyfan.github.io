<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | NOEY]]></title>
  <link href="http://fyou.me/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://fyou.me/"/>
  <updated>2021-04-06T22:53:36-07:00</updated>
  <id>http://fyou.me/</id>
  <author>
    <name><![CDATA[Fan You]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dynamic Configuration System]]></title>
    <link href="http://fyou.me/blog/2019/05/04/dynamic-configuration-system/"/>
    <updated>2019-05-04T16:31:01-07:00</updated>
    <id>http://fyou.me/blog/2019/05/04/dynamic-configuration-system</id>
    <content type="html"><![CDATA[<h2>Index</h2>

<p>[TOC]</p>

<h2>Overview</h2>

<p>People all like generic software solutions, but as the scale of modern computer system grows larger, there are business logic cannot be avoided in order to handle real world complexity, Tax Rules, Accounting Treatment, Pricing/Deal calculation…</p>

<p>However, write business logic in code was never recommended because it will result in</p>

<ul>
<li>Hard-to-read code: code are not readable without huge documentation</li>
<li>Hard-to-test code: code will be tested against specific business and not able to test generically</li>
<li>Hard-to-change code: change won&rsquo;t be in effective until code deploy and also hard to revert</li>
<li>Hard-to-analyze data being processed: metrics can not be easily emitted and analyzed</li>
</ul>


<p>Here is where a dynamic configuration system (short for DCS) comes into play and we will see how it solves all these problems.</p>

<h2>Definition</h2>

<p>A DCS abstracts business logics layer from other layer in a readable and testable fashion during runtime, it should generally allow store, edit, update configuration as well as fetch them by certain conditions.</p>

<p>To put it simple, a client of a DCS should be able to</p>

<ul>
<li>PutConfig: upload configurations containing business logics</li>
<li>GetConfig: fetch configuration by filters</li>
<li>ProcessConfig: given inputs, DCS should match against stored config and produce results</li>
</ul>


<p><img src="/images/flare.png" alt="flare" /></p>

<h2>Modeling</h2>

<p>Model of a configuration is tightly coupled with its functionality. Here we will only cover the essential functionality of the DCS where new result should be produce by given input and configuration.</p>

<p>e.g. input:</p>

<pre><code>input::
{
  attribute_1: value_1
}
</code></pre>

<p>and config:</p>

<pre><code>when attribute_1 == value_1, produce attribute_2 = value_2
</code></pre>

<p>we should get:</p>

<pre><code>{
  attribute_2: value_2
}
</code></pre>

<p>as a response. (The above syntax is <a href="http://amzn.github.io/ion-docs/">ion</a>)</p>

<p>Then its not hard to infer the very basic piece of a configuration is a compose of <code>condition</code> and <code>resulting value</code>. (Lets call it a derivation config) A naive model can look like this:</p>

<pre><code>{
  condition: {
    condition: cond,
  },
  value: {
    value: v,
  }
}
</code></pre>

<p>and of course a group of derivation config can be written as:</p>

<pre><code>{
  conditions: {
    condition_1: cond_1,
    condition_2: cond_2,
    ...
  },
  values: {
    value_1: v_1,
    value_2: v_2,
    ...
  }
}
</code></pre>

<p>and multiple conditions are <code>and</code> relationship.</p>

<h2>Storage</h2>

<p>We have the model of derivation configuration now, but how can we store them? A traditional relational database and reference by id? or a document based storage reference by nature key? Let&rsquo;s take a look at both of them.</p>

<h4>Relational</h4>

<table>
<thead>
<tr>
<th> row_id </th>
<th style="text-align:left;"> config_element_id </th>
<th> config_data                          </th>
</tr>
</thead>
<tbody>
<tr>
<td> 1      </td>
<td style="text-align:left;"> 1                 </td>
<td> {conditions:{c_1, c_2}, value:{v_1}} </td>
</tr>
<tr>
<td> 2      </td>
<td style="text-align:left;"> 2                 </td>
<td> {conditions:{c_1,c_2}, value:{v_2}}  </td>
</tr>
<tr>
<td> &hellip;    </td>
<td style="text-align:left;"> &hellip;               </td>
<td> &hellip;                                  </td>
</tr>
</tbody>
</table>


<p>Benefit of this approach is:</p>

<ul>
<li>Strong consistency guarantee, much easier to work with in a multi-thread access environment</li>
</ul>


<p>Downside of this approach is: (All come from the persistence identifier!!)</p>

<ul>
<li>Extra cost to maintain additional id. id is required to be present everywhere in the DCS, big waste of space!!</li>
<li>Requires additional joins when querying, slow down the access speed!</li>
<li>Huge pain when it comes to editing the configuration, id has to be carefully handled and matched. (Simple diff doesn&rsquo;t work!)</li>
<li>Duplicate check can be hard, even though 2 config data is duplicate, we still treat them as different if they have different <code>config_element_id</code></li>
</ul>


<p><strong><em>Despite all those negative thing with relational database and persistence identifier, we will still be using this approach in this article because this has been proven to work in production environment.</em></strong></p>

<h4>NoSql</h4>

<table>
<thead>
<tr>
<th> key                                           </th>
<th> value </th>
</tr>
</thead>
<tbody>
<tr>
<td> condition_1:cond_1/condition_2:cond_2/value_1 </td>
<td> v_1   </td>
</tr>
<tr>
<td> condition_1:cond_1/condition_2:cond_2/value_2 </td>
<td> v_2   </td>
</tr>
<tr>
<td> &hellip;                                           </td>
<td> &hellip;   </td>
</tr>
</tbody>
</table>


<p>Benefit of this approach are:</p>

<ul>
<li>Simpler data model, no separate persistence identifier resulting in faster query speed</li>
</ul>


<p>Downside of this approach are:</p>

<ul>
<li>Hard to guarantee consistency (Especially in a distributed k-v store, manual distributed lock has to be implemented and maintained by DCS)</li>
</ul>


<h3>In-Memory</h3>

<p>It&rsquo;s expensive to always go back to database and retrieve information for every operation DCS needed. An in-memory representation of configuration is also needed.</p>

<p>The most nature way of storing key-value pair chain is <code>Trie</code>, and that&rsquo;s what we are going to use:</p>

<pre><code>               root
                |
           condition_1
        /                 \
 cond_3 {value_2: v2}   cond_1 {value_1: v_1}
                          \
                          condition_2           
                            \
                            cond_2 {value_1: v_1}
</code></pre>

<p>Is a representation of</p>

<pre><code>{
  conditions: {
    condition_1: cond_3,
    condition_2: cond_2,
  },
  values: {
    value_1: v_1,
  }
}

{
  conditions: {
    condition_1: cond_1,
  },
  values: {
    value_2: v_2,
  }
}
</code></pre>

<p>Ordering of conditions in tree are guaranteed by alphabetic order by default and is &ldquo;configurable&rdquo; for different tenant of DCS.</p>

<p>To formalize a little bit, a config tree node can be represent as (in haskell)</p>

<pre><code class="haskell">data ConfigElement = ConfigElement
data Trie = Empty | TrieNode String String ConfigElement [Trie]
</code></pre>

<h4>S3, Caching and Interning</h4>

<p>In-memory Tree are also not directly built from RDS database because it can take minutes or even ours to load few entire tree, instead, every latest changes are truncated to a snapshot, serialized &amp; compressed to store in S3, 99% of the time, s3 are the storage used to fetch the configuration.</p>

<p>In-memory Tree in DCS are 1 tree per snapshot and that&rsquo;s what DCS keeps in the cache as well. If an entire tree is 4GB, and a typical DCS host has 60GB, only 15 snapshot can be stored at maximum! Request will have a huge latency spike if there is a cache miss. Here comes the idea of interning.</p>

<p>Interning (like String interning) is a technique to share repetitive in-memory object by putting them in a poll. This saves the memory of cache because multiple snapshot shares the same piece of subtree. And DCS calculates repetitive solely based on its hash key.</p>

<h4>Filtering and Indexing</h4>

<p>One interesting thing about fetch configuration in DCS is filter. DCS supports filter that allow access configuration from different dimension. e.g. by config_element_id, by status&hellip;</p>

<p>This means different indexing of the configuration has to be built, there are global index for indexing config_element_id (unique), there are per snapshot index for content key to perform duplicate lookup&hellip;</p>

<p>Keep adding index is also not scalable and interning won&rsquo;t help because different index will likely have very little to share. A DCS might consider using graph based DB to better help with indexing and querying tasks.</p>

<h4>Collapsing Configuration</h4>

<p>TODO</p>

<h4>Tenant Separation</h4>

<p>Muti-tenancy is an important consideration for DCS:</p>

<ul>
<li>Every config element and operation should be directly or indirectly associated with a tenant and they can be traced from the Database</li>
<li>Request for DCS should always pass in tenant, and ownership shall validate &amp; approve the request before any operation</li>
<li>Tenant should be able to easily manage their tenant configuration (e.g. ownership)</li>
</ul>


<h2>Authoring</h2>

<p>Authoring is the process of PutConfig into DCS. Enable parallel editing, bulk editing and consistency model will be the main focus of this section.</p>

<h4>Why not using Git?</h4>

<p>Git treat each line (or even character if you&rsquo;d like) as the lowest granular editing, however our DCS treat a single config element change as the lowest granular editing. They are fundamentally different!! Using git means we cannot use &ldquo;line changes&rdquo; of git directly as &ldquo;config element&rdquo; changes which immediately brings no benefit of using git! Plus, change can be very hard to validate before pushing, traditional pull/rebase/code review/push model won&rsquo;t work because DCS are changing so rapidly and concurrently!!</p>

<p>It then became very obvious that instead of hack Git and trying to put different pieces together, we are better off building our own authoring workflows.</p>

<h4>Change List</h4>

<p>Change list is a list of config elements that represents changes a person is trying to make in DCS.</p>

<table>
<thead>
<tr>
<th> change_list_id </th>
<th> change_list_revision </th>
<th> config_element_ids </th>
</tr>
</thead>
<tbody>
<tr>
<td> 1              </td>
<td> 1                    </td>
<td> [1,2,3]            </td>
</tr>
<tr>
<td> 1              </td>
<td> 2                    </td>
<td> [4]                </td>
</tr>
<tr>
<td> 2              </td>
<td> 1                    </td>
<td> [5,6]              </td>
</tr>
</tbody>
</table>


<h4>Work Request</h4>

<p>Work request act as a container for change list. A Work Request can have multiple change list but a Release can only have one work request. A typical WR contains 2 type of change list:</p>

<ul>
<li>1 Active change list: track changes that has not been released (all updates are write to this change list)</li>
<li>(0 ~ Many) Change Lists: all change list that has a release associated</li>
</ul>


<p>Concurrent update to work request are guaranteed by optimistic locking mechanism. A work request update always require both change list id and change list revision, if an older revision of change list is being submitted to the database, it will get rejected.</p>

<p>Initially work request were designed to have no revision associated, but as time goes, it became more obvious that add revision to work request can provide better audit history of work request updates and potential work request snapshot for running reproducible tests.</p>

<h4>Snapshot</h4>

<p>Snapshot is an important concept in DCS as it provides a way to represent an immutable set of configurations. This enable audit history of all configuration changes and also point-in-time recovery (or reproduce of the transaction). There are 3 types of Snapshot:</p>

<ul>
<li>Latest Snapshot (aka Base Snapshot or Release Snapshot): track the latest snapshot of a given domain</li>
<li>Config Update Snapshot: track a snapshot for change list</li>
<li>Merge Snapshot: containing multiple snapshots and a resolver containing instruction on how to merge them</li>
</ul>


<h4>Release Process</h4>

<p>An release process in DCS transform the latest state of DCS from 1 good snapshot to another. The soundness of change are guaranteed during the release process. A typical release workflow contains:</p>

<ul>
<li>Duplicate check</li>
<li>Reference check</li>
<li>Conflict check</li>
<li>Run test</li>
<li>Merge or Rebase</li>
</ul>


<p>A DCS cannot be successful without a well defined &amp; executed release process</p>

<h4>Concurrent release</h4>

<p>Config Update Snapshot -> Merge Snapshot -> Release Snapshot (Optimistic Locking)-> Latest Snapshot</p>

<p>concurrency were simply handled by an optimistic locking between building release snapshot and promote  as latest snapshot. latest snapshot table are updated by providing domain, release snapshot and latest snapshot. No duplicate revision can be created and that&rsquo;s guaranteed by database transactions which also guarantee the concurrent update to the DCS.</p>

<h4>Rebase</h4>

<p>There are a situation where 2 releases changing different config elements and trying to release at the same time, due to the fact that only 1 snapshot can be marked as live at given time, one of those 2 releases will always fail. However, there is a smarter way we can do to ensure both release success by rerun part of the release workflow (aka. Release process)</p>

<p>Whenever a release fail to be marked as succeeded, DCS will check the error type, if the type is OUT_OF_DATE_BASE_SNAPSHOT, which means there are other release succeeded before this release finishes, a rebase workflow can be kick off.</p>

<p>A rebase workflow essential bypass all the manual approval steps and only run the automated validation/testing steps and then trying to merge in again. However, it&rsquo;s possible for an unlucky release (starving) to keep running rebase workflow and maybe never succeed.</p>

<p>In order to solve release starving problem, preemptive rebase mechanism was introduced, all the pending rebase release will be put in a queue and every release will pre-computes changes that needs rebase base on release ahead of them in the queue. (A new RebaseAttemp object and Preemptive Rebase Workflow is introduced and replaced old rebase workflow)</p>

<h4>Partial release</h4>

<p>partial release is the feature of release only a subset config within the work request. It was originally implemented using a concept of Release Unit, which can be created from path of the tree. A request of partial release will have normal release object plus a specific Release Unit and DCS will figure out what need to be released.</p>

<p>Release Unit soon became a pain because it creates additional layer between change list and release/work request, its both programmatically difficult to figure out relationship between release unit, release and work request and un-intuitive for end user to create a correct Release Unit.</p>

<p>Release Unit based partial release was then deprecated by partial release via raw tree where release request will contain a tree that explicitly describing what should be released.</p>

<h4>Tree Operation</h4>

<h6>Merge</h6>

<p>Merge is a multiple tree operator which can be applied to 2 or more trees. Tree Merger folds the tree one by one and it first creates a conflict tree out of merging trees and then use resolver to transform them back into a normal tree, resolver is required by Tree Merger and sample resolvers are:</p>

<ul>
<li>last_one_wins: just use the last node seen</li>
<li>optimistic_locking: ensure right node (CE) must have larger revision than left node, otherwise merge will fail and this is the only resolver that might fail. This is also the default resolver used in release process.</li>
<li>latest_revision: use the latest dated_released_config_revision</li>
</ul>


<h6>Conflict Resolution</h6>

<p>Conflict happens all the time during release due to optimistic_locking resolver and simultaneously modification of the same config. Conflict Resolution mechanism provides a way for user to get the conflict tree in their release and select side of the tree, manually resolve the conflict and resume the release.</p>

<p>DCS did this by deleting conflicted configs and adding a new config back as user selected. However, this did introduced an interesting bug (and caused a COE). Because the way DCS are adding new configs instead of re-using existing ones to actually &ldquo;resolve&rdquo; the conflict, duplicate configs can easily be added. Someone actually took advantage of this bug and duplicated an entire namespace multiple times!!</p>

<p>This was later fixed by adding duplicate check across the platform but removing existing duplicate is very hard and still on going.</p>

<h6>Diff</h6>

<p>Diff is a dual tree operator which can only be applied to 2 trees. Tree Differ perform a transformation from 2 StandardTree to 1 DiffTree where each node is of type DiffNode and contains a left and right.</p>

<p>Diff tree can be transform to StandardTree again by traversal the tree and select left or right. In fact, config update snapshot should was produce by selection all right side of a Diff tree.</p>

<h4>Testing</h4>

<p>Test cases are in/out files that can be executed against certain snapshot, they are defined &amp; authored the same way as other configuration in DCS but in a separate namespace.</p>

<p>Testing will be done in a custom test suit which will take care of getting test configuration, convert it to java test cases and then start a in-memory DCS (processing engine) to process test cases.</p>

<p>We faced few performance issue where test run are getting extensively slow after sometime. Since we know  testing are CPU-intensive calculation, mostly the focus on optimization were done one CPU. However, it turns out with the increase in test case size, JVM is running out of heap. A lot of CPU cycle was wasted on busy GC. Simple increasing heap size improved the testing time to be 10x faster. (<a href="https://gceasy.io/">gceasy.io</a> was the tool helped a lot)</p>

<h3>Ownership</h3>

<p>Too low granular to use.</p>

<h2>Processing</h2>

<p>I wrote a very basic <a href="https://gist.github.com/Noeyfan/a9f58e2a447e8ed7773c87b6e0400723">haskell program</a> demonstrating how processing against tree works. It basically has a main process function where it loop through each record then try to derive attributes/record. Newly derived record will be directly append to original record list (so the function is not pure and it relies on IonList implementation to work correctly)</p>

<h4>Best Match</h4>

<h4>Execution Context</h4>

<h4>Namespace</h4>

<h2>Analytics</h2>

<p>TODO</p>

<h2>Future</h2>

<p>DSL and DCS</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于堆分配和栈分配思考以及指针和引用]]></title>
    <link href="http://fyou.me/blog/2014/12/31/heapstack/"/>
    <updated>2014-12-31T01:33:26-05:00</updated>
    <id>http://fyou.me/blog/2014/12/31/heapstack</id>
    <content type="html"><![CDATA[<h4>栈分配</h4>

<p>传统栈分配的例子:
<code>C
int GiveVal(int a) {
    int x = a;
    return x;
}
</code>
这是合法的栈分配意思是在执行完整个方法后,将里边的数据copy一份,return给外边以后,再将自身的数据a,x释放掉。</p>

<h4>堆分配的产生</h4>

<p>由于栈分配在小规模操作的时候还好,但是上升到大规模的运算时候,拷贝的速度会变的非常的慢。
所以就干脆不释放运算过程中的数据，直接将地址return出来。
传统做法是这样的:
<code>C
FWidget* CreateWidget(int x, int y, int z)
{
    FWidget* NewWidgetPointer = new FWidget(x,y,z);
    return NewWidgetPointer;
}
</code></p>

<h4>引用</h4>

<p>int b = 3;
int&amp; a = b;
这个等价于
int b = 3;
int<em> ap = &b;
a = 4; 等价于 </em>ap = 4;
&amp;a 等价于 ap
唯一不等价的是你没法改ap指向谁
ap只能指向b，不能换人</p>

<h4>例题</h4>

<p>下图方法有什么问题:
<code>C
FWidget&amp; CreateWidget(int x, int y, int z)
{
    FWidget NewWidget(x,y,z); // 栈分配
    return NewWidget;
}
</code>
等价写法:
<code>C
FWidget* CreateWidget(int x, int y, int z)
{
    FWidget  NewWidget(x,y,z);
    return &amp;NewWidget;
}
</code>
问题:
return 出去以后原来的东西就被释放了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对于int64, int32的一点理解]]></title>
    <link href="http://fyou.me/blog/2014/12/30/int/"/>
    <updated>2014-12-30T14:34:44-05:00</updated>
    <id>http://fyou.me/blog/2014/12/30/int</id>
    <content type="html"><![CDATA[<h3>基本概念</h3>

<p>32/64 表示的是数字长度</p>

<h4>int32_t 4byte * 8 = 32</h4>

<p>表示范围是: -(2<sup>31</sup>+1) ~ 2<sup>31</sup>-1</p>

<h4>uint32_t</h4>

<p>表示范围是: 0 ~ 2<sup>32</sup>-1</p>

<h4>int64_t 8byte * 8 = 62</h4>

<p>表示范围是: -(2<sup>63</sup>+1) ~ 2<sup>63</sup>-1</p>

<h4>uint64_t</h4>

<p>表示范围是: 0 ~ 2<sup>64</sup>-1</p>

<h3>进制转换</h3>

<p>hex(10) = dec(16)</p>

<h3>编译区别</h3>

<p>cc -m32 a.cc
cc -m64 a.cc</p>

<p>指针大小是不相同的64位下是8byte, 32位下是4byte.</p>

<p>原因:就是说,现代操作系统比较贴心,每个程序运行的时候都给你一个大大的独占的内存条,对于32位系统来说，给的内存条大小为2<sup>32</sup>字节,也就是4GB
对于64位系统来说,给的内存条大小是2<sup>64</sup>字节,也就是数不清的字节
当然不可能真给你这么大。策略是你用多少就给你多少
但是你仿佛有一个超大内存可以独霸
所有的指针都是存的这个超大内存的地址
自然,32位系统的指针是4字节，因为一共有2<sup>32</sup>个格子嘛,4字节就是32位数,每个数对应一个格子,也就是存了32个01.
64位的话只是更多而已,依然是一一对应</p>

<h3>数组与指针后移</h3>

<p>假设T a[] = {};
已知a地址为A
a+1 的地址是&mdash;&ndash;> A + sizeof(T); // 此处是T而不是T*</p>

<h3>补码反码表示</h3>

<p>C中 ^表示异或计算 (不同为1,相同为0)
      ~表示按位取反 (计算机中求负数 = 取反+1)
        如果出现要求返回是uint却返回了负数的情况,计算机会吧他取反+1当成uint来计算。 -8 = ~8 + 1 = 2<sup>32</sup> -1 -8 +1</p>

<h3>关于所谓的符号位</h3>

<pre><code>    举例说明:
    比如一个一字节的数:
    0 ~ 0111 1111是正数,表示0~127
    1000 0000 ~ 1111 1111是负数,表示-128 ~ -1
    每个正数取反加一就是相应的负数
    -128比较诡异,因为没有对应的正数

    也就是说最高位是1表示正,是0表示负这个没错,但是具体求的时候,始终是取反+1
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP Server-Client 实现]]></title>
    <link href="http://fyou.me/blog/2014/11/24/tcp-prectise/"/>
    <updated>2014-11-24T22:22:50-05:00</updated>
    <id>http://fyou.me/blog/2014/11/24/tcp-prectise</id>
    <content type="html"><![CDATA[<p>出于练习目的，决定自己实现一遍client-server的基础模型.
<a href="https://github.com/Noeyfan/crack_code_interview/tree/master/socket">源码</a></p>

<h4>Server端</h4>

<p>1.申明并取得启用服务地址的一系列参数(这里通过命令行输入).</p>

<pre><code class="C">struct sockaddr_in server;
struct sockaddr_in client;
int port, connectfd, sin_size;
sin_size = sizeof(struct sockaddr_in);

port = htons(atoi(argv[2])); //端叙转换,atoi只用于转换数字
//转化时跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时('/0')才结束转换，并将结果返回。

server.sin_family = AF_INET;
server.sin_port = port;
server.sin_addr.s_addr = htonl(INADDR_ANY); //localhost
</code></pre>

<p>2.创建socket, 并设置为resuable(并发服务器)</p>

<pre><code class="C">int socketfd = socket(AF_INET, SOCK_STREAM, 0); //返回int
int opt = SO_REUSEADDR;
setsockopt(socketfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));
</code></pre>

<p>3.bind 和listen</p>

<pre><code class="C">if(bind(socketfd, (struct sockaddr *) &amp;server, sizeof(struct sockaddr)) == -1) {
    perror("Bind error");
    exit(1);
}

if(listen(socketfd, 5) == -1) {
    perror("listen() error\n");
    exit(1);
}
</code></pre>

<p>4.accept卡住程序，等待客户连入，一但连入，开thread处理client</p>

<pre><code class="C">if((connectfd = accept(socketfd, (struct sockaddr *)&amp;client, (socklen_t *)&amp;sin_size)) == -1){ //connectfd is only for process request
    perror ("accept() error \n");
    exit(1);

    struct ARG* arg = (struct ARG*)malloc(sizeof(struct ARG));
    arg-&gt;connfd = connectfd;
    connarr[cnt++] = connectfd;
    printf("connect fd after is : %d", arg-&gt;connfd);
    arg-&gt;client = client;
    if(pthread_create(&amp;thread, NULL, start_routine, (void*)arg)) { //if get strange thing, most likely is pass parameter
        perror("pthread create error");
        exit(1);
    }
}
</code></pre>

<h4>Client端</h4>

<p>1.载入server参数</p>

<pre><code class="C">struct sockaddr_in server_addr;
//两种方法获取server_addr
//1. 可以读取localhost
struct hostent *server;
server = gethostbyname(argv[1]);
bcopy(server-&gt;h_addr, &amp;server_addr.sin_addr,server-&gt;h_length);

//2. 直接对server_addr放入ipaddr
socketaddr.sin_addr.s_addr = inet_addr("127.0.0.1"); // 127.0.0.1可以是任何string
</code></pre>

<p>2.connect to the Server</p>

<pre><code class="C">if(connect(sockfd, (const struct sockaddr *)&amp;server_addr,sizeof(server_addr)) &lt; 0) {
    printf("fail to connect");
}
</code></pre>

<p>3.开thread去处理服务器发来的信息
<code>C
if(pthread_create(&amp;thread1, NULL, &amp;start_receive, (void*)arg)){
    perror("listen create error");
    exit(1);
}
</code></p>

<p>4.在另外的while loop里进行发送
<code>C
while(1) { // must
    sendRequest(sockfd, argv[3]);
    //在sendRequest里用fegets卡住程序.
}
</code></p>

<h4>I/O复用提高效率</h4>

<p>基本概念(从非阻塞轮询到select/poll到epoll)</p>

<p>1.非阻塞轮询:不停检测所有io,有数据则读取
<code>
while(true) {
    for (i in stream[]){
        if (i has data){
            read all;
        }
    }
}
</code></p>

<p>2.为了避免cpu空转:引入select代理
同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流
<code>
while(true) {
    select(stream[]);
    for (i in stream[]){
        if (i has data){
            read all;
        }
    }
}
</code>
于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。</p>

<p>3.epoll (event poll)
epoll会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的,复杂度降低到了O(k)，k为产生I/O事件的流的个数.
<code>
while(true) {
    active_stream[] = epoll_wait(epollfd)
        for (i in active_stream[]) {
            read or write till unavailable
        }
}
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Function Pointer]]></title>
    <link href="http://fyou.me/blog/2014/11/22/p-thread/"/>
    <updated>2014-11-22T16:19:47-05:00</updated>
    <id>http://fyou.me/blog/2014/11/22/p-thread</id>
    <content type="html"><![CDATA[<p>今天才知道各各系统的man是不一样的,mac下查man还是上网查把。</p>

<p>0.前言 <a href="https://github.com/Noeyfan/CodingPractice/blob/master/virtual/virtualFunctionC.c">C实现virtual function</a></p>

<pre><code>函数:
{返回值类型} {函数名}({参数列表})这个格式你应该很熟悉了，就是函数

函数指针:函数指针也是一种变量，可以直接以函数名赋值
{返回值类型} （*{变量名}）({参数列表})

变量声明:
{类型} {和表达式很像的东西}
</code></pre>

<p>1.基础应用(1)
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">typedef</span> <span class="nf">float</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">pf</span><span class="p">)</span> <span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="p">);</span>
</span><span class='line'><span class="c1">//pf 是函数指针类型,注意此处&lt;/em&gt;的位置，表示取值</span>
</span><span class='line'><span class="c1">//typedef 将pf变成一个类型</span>
</span><span class='line'><span class="c1">//如果没有typedef,需要对每个同样函数指针的定义做相同的事情</span>
</span><span class='line'><span class="c1">//float (&lt;em&gt;pf)(float, float);</span>
</span><span class='line'><span class="c1">//float (&lt;/em&gt;a)(float, float);</span>
</span><span class='line'><span class="c1">//此处变量名也可以省去，方便YY :)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">float</span> <span class="n">foo</span><span class="p">(</span><span class="n">flaot</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">pf</span> <span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span>
</span><span class='line'>    <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>2.基础应用(2)
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">add</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">imp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">fp</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">main</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">result</span> <span class="n">is</span> <span class="o">%</span><span class="n">i</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="n">imp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">add</span><span class="p">));</span>
</span><span class='line'>          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
3.两种定义形式</p>

<ul>
<li>C: 返回类型 (*函数指针名称)(参数类型,参数类型,参数类型，…);</li>
<li>C++: 返回类型 (类名称::*函数成员名称)(参数类型，参数类型，参数类型，…);</li>
</ul>


<p>4.函数指针作为返回值
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">(</span><span class="kt">char</span> <span class="n">op</span><span class="p">))(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="o">+&amp;</span><span class="n">rsquo</span><span class="p">;)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">add</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">signal</span><span class="p">)(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span><span class="kt">void</span> <span class="p">(</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">func</span><span class="p">)(</span><span class="kt">int</span><span class="p">))(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="c1">//unix 系统函数</span>
</span><span class='line'><span class="c1">//函数名称signal</span>
</span><span class='line'><span class="c1">//接受两个参数- int 和 一个函数指针</span>
</span><span class='line'><span class="c1">//返回函数指针类型为: void(*)(int)</span>
</span><span class='line'><span class="c1">//照着读signal 调用两次以后返回void&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">main</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">returnpf</span><span class="p">)(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// (&lt;/em&gt;returnpf) 这个括号不能少</span>
</span><span class='line'>    <span class="n">returnpf</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="o">+&amp;</span><span class="n">rsquo</span><span class="p">;);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">result</span> <span class="n">is</span> <span class="o">%</span><span class="n">i</span><span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="p">(</span><span class="o">*</span><span class="n">returnpf</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
</span><span class='line'>    <span class="c1">//or</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">result</span> <span class="n">is</span> <span class="o">%</span><span class="n">i</span><span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="n">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="o">+&amp;</span><span class="n">rsquo</span><span class="p">;)(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>5.函数指针数组
<code>C
float (*pFunctionArray[10])(float, float);
</code></p>

<p>6.用typedef 简化函数
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">pf</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="c1">//void (&lt;/em&gt;signal)(int signo,void (*func)(int))(int);</span>
</span><span class='line'><span class="c1">//= pf signal(int signo, pf func);&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">typedef</span> <span class="kt">void</span> <span class="n">pf</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="c1">//void (&lt;em&gt;signal)(int signo,void (&lt;/em&gt;func)(int))(int);</span>
</span><span class='line'><span class="c1">// = pf&lt;em&gt; signal(int signo, pf&lt;/em&gt; func);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>7.附言，米米的教导 <a href="http://www.zhihu.com/question/20635559/answer/19669437">米米知乎解答</a>
<code>C
int (*signal[4])(int)(char)[6];
//变量申明
//该表达式返回int
//所以(*signal[4])(int)(char)返回一个int指针(可以用作[6])
//(*signal[4])(int)是一个函数指针，接受参数char，返回int指针
//signal[4]是一个函数指针，接受int，返回另一个函数指针，后者的函数类型如上所述，“接受char，返回int指针”
//现在signal是啥呢，肯定是个数组。什么数组呢？上一条那玩意的数组
//结论:signal是一个函数指针数组，函数指针的函数类型为：接受int，返回另一个函数指针，后者的函数类型为“接受char，返回int指针”
</code></p>

<p>8.如何使用<code>function pointer</code> 实现dynamic dispatch?</p>

<p>原理非常简单就是在初始化时候将内部的function pointer，指向implementation的真实function从而达到目的。</p>

<pre><code class="c">void funA_imp() { printf("world"); }

void funBase_imp() { printf("hello"); }

struct Base { void (*fun)(); };

struct A { void (*fun)(); };

int main() {
    struct Base b;
    // dynamic dispatch
    // struct A a;
    // a.fun = &amp;funA_imp;
    // b.fun = a.fun;
    b.fun = &amp;funBase_imp;
    b.fun();
}
</code></pre>

<p><code>virtual function</code> 也是同理</p>

<p><code>Base class</code> maintain 一个<code>__vptr*</code> 指向真实的<code>vtable (array of functions)</code> implementation，而所有的<code>derived class</code> 包括 <code>base</code> 自己都有一个 <code>vtable</code> 的implementation.</p>

<p>下面 class A in c++：</p>

<pre><code class="c++">class A {
protected:
    int a;
public:
    A() {a = 10;}
    virtual void update() {a++;}
    int access() {update(); return a;}
};

class B {
  public:
    void update() {a--;}
};
</code></pre>

<p>可以用c这么实现：</p>

<pre><code class="c">struct A;

typedef struct {
    void (*A)(struct A*);
    void (*update)(struct A*);
    int (*access)(struct A*);
} A_functable;

typedef struct A{
    int a;
    A_functable *vmt;
} A;

void A_A(A *this);
void A_update(A* this);
int A_access(A* this);

A_functable A_vmt = {A_A, A_update, A_access};

void A_A(A *this) {this-&gt;vmt = &amp;A_vmt; this-&gt;a = 10;}
void A_update(A* this) {this-&gt;a++;}
int A_access(A* this) {this-&gt;vmt-&gt;update(this); return this-&gt;a;}

/*
class B: public A {
public:
    void update() {a--;}
};
*/

struct B;

typedef struct {
    void (*B)(struct B*);
    void (*update)(struct B*);
    int (*access)(struct A*);
} B_functable;

typedef struct B {
    A inherited;
} B;

void B_B(B *this);
void B_update(B* this);

B_functable B_vmt = {B_B, B_update, A_access};

void B_B(B *this) {A_A(this); this-&gt;inherited.vmt = &amp;B_vmt; }
void B_update(B* this) {this-&gt;inherited.a--;}
int B_access(B* this) {this-&gt;inherited.vmt-&gt;update(this); return this-&gt;inherited.a;}

int main() {
    A x;
    B y;
    A_A(&amp;x);
    B_B(&amp;y);
    printf("%d\n", x.vmt-&gt;access(&amp;x));
    printf("%d\n", y.inherited.vmt-&gt;access(&amp;y));
}
</code></pre>
]]></content>
  </entry>
  
</feed>
