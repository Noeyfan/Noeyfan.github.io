<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[NOEY]]></title>
  <link href="http://fyou.me/atom.xml" rel="self"/>
  <link href="http://fyou.me/"/>
  <updated>2015-10-07T16:22:40-04:00</updated>
  <id>http://fyou.me/</id>
  <author>
    <name><![CDATA[Fan You]]></name>
    
  </author>

  
  <entry>
    <title type="html"><![CDATA[GSoC 2015 小结]]></title>
    <link href="http://fyou.me/blog/2015/09/07/gsoc2015/"/>
    <updated>2015-09-07T00:02:53-04:00</updated>
    <id>http://fyou.me/blog/2015/09/07/gsoc2015</id>
    <content type="html"><![CDATA[<p>GSoC 2015 也算是结束了，期间学到了很多，也认识到了很多不足，拖延症患者拖到今天终于决定下笔记录下这一段经历，以便往后温习，吹逼之用。</p>

<h2>Extend shared_ptr to support arrays</h2>

<p>第一个Propose的项目是<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4335.html#memory.smartptr.shared">extend shared_ptr to support arrays</a>. 初始由于C＋＋技艺不精，甚至不知道shared_ptr是什么，所以先从shared_ptr的源码讲起吧。</p>

<h4>shared_ptr</h4>

<p>shared_ptr位于<code>libstdc++-v3/include/bits/shared_ptr.h</code>，这里的shared_ptr其实是对所有开放接口的一个封装，真正的实现在<code>shared_ptr_base.h</code>里。</p>

<p>找到__shared_ptr定义的private member，会发现只有两个东西</p>

<ol>
<li><em>Tp* </em>M_ptr;_                                                 // Contained Pointer</li>
<li>_<em>shared_count<_LP> </em>M_refcount;           // Reference counter</li>
</ol>


<p>shared_ptr的实现也就依赖这两个东西，一个raw pointer，另一个引用计数。有新的object使用raw pointer refcount++, 同样destructor调用一次refcount- -,如果refcount ＝＝ 0，那么就释放_M_ptr;</p>

<p>// 注（</p>

<p>一个裸指针被托管以后，任何想要使用这个指针的行为都得通过shared_ptr，否则UB</p>

<p>例如</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">int</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span><span class='line'><span class="c1">// int* b = a;</span>
</span><span class='line'><span class="c1">// std::shared_ptr sb(b); undefined behavior</span>
</span><span class='line'><span class="k">auto</span> <span class="n">sb</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span> <span class="c1">// refcount+1</span>
</span></code></pre></td></tr></table></div></figure>


<p>）</p>

<p>说起来很简单，但是shared_ptr确实还是有不少坑。</p>

<h4>weak_ptr</h4>

<p>shared_ptr难免会出现这样的情况（cyclic reference），weak_ptr可以让持有执政却不增加引用计数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">();</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">y</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">x</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// not quite a cycle yet</span>
</span><span class='line'>  <span class="n">y</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// now we got a cycle x keeps y alive and y keeps x alive</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样的情况，如果x 拿了一个指向y的weak_ptr就不存在这样的问题了。weak_ptr的用处很多，如<a href="http://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful">cache</a>。</p>

<h4>enable_shared_from_this</h4>

<p>参见我在知乎的<a href="http://zhihu.com/question/30957800/answer/50181754?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu">答案</a>。用于在类内部拿取自身的shared_ptr。</p>

<p>在每次构造一个<code>shared_ptr&lt;T&gt;</code>时都会检查T是否继承自enable_shared_from_this，如果是，会在自身的private member里保存一个weak_ptr，以后用shared_from_this()拿取自身的shared_ptr.</p>

<h4>support for arrays</h4>

<p>来到正题，shared_ptr虽然好用，但是对数组的支持并不好，也就是说，可以用但是基本没用。需要传入自己的destructor以保证资源正确释放。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;memory&gt;</span>
</span><span class='line'>
</span><span class='line'> <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class='line'>   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span><span class="o">*</span><span class="n">p</span> <span class="p">){</span><span class="k">delete</span> <span class="n">p</span><span class="p">;});</span>
</span><span class='line'> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了将数组支持加入shared_ptr且保证之前使用shared_ptr的代码不出错，决定使用一个新的tag</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__libfund_v1</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">_Tp</span><span class="p">;</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>来和原本的__shared_ptr加以区分。</p>

<ol>
<li><p>做一个</p>

<pre><code class="c++">class __shared_ptr&lt;__libfund_v1&lt;T&gt;&gt;
:__shared_ptr&lt;typename remove_extent&lt;_Tp&gt;::type, _Lp&gt;{ }
</code></pre>

<p>//注（此处应做成private继承）</p></li>
<li><p>内部准备两个Deleter: _Array_Deleter 和 _Normal_Deleter。</p></li>
<li><p>根据T的类型选择使用Deleter</p>

<pre><code class="c++">using _Deleter_type
= typename conditional&lt;is_array&lt;_Tp&gt;::value,_Array_Deleter,_Normal_Deleter&gt;::type;
</code></pre></li>
<li><p>其他的情况只要pass到基类处理就好。</p></li>
</ol>


<p>整体的难度不是很大，但摸清gcc的coding style和这些代码的工作原理，着实费了番工夫。</p>

<p>当shared_ptr用在array时，其中有种情况跟原本不一样, 原本shared_ptr的构造函数可以接受能够进行implicit cast的类型。当放到数组是这一规则不再适用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span> <span class="p">};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span> <span class="c1">// ok</span>
</span><span class='line'>  <span class="n">Base</span> <span class="n">b_array</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'>  <span class="n">b_array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// if Base and Derived are of difference</span>
</span><span class='line'>                              <span class="c1">// b_array[1] may cause trouble. &quot;pointer arithmatic&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>技巧</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">// helper for _Compatible</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_From_type</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_To_type</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__sp_compatible_helper</span>
</span><span class='line'>  <span class="p">{</span> <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">value</span>
</span><span class='line'>    <span class="o">=</span> <span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">_From_type</span><span class="o">*</span><span class="p">,</span> <span class="n">_To_type</span><span class="o">*&gt;::</span><span class="n">value</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">_Nm</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__sp_compatible_helper</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">[</span><span class="n">_Nm</span><span class="p">],</span> <span class="n">_Tp</span><span class="p">[]</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="p">{</span> <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++中用偏特化做SFINAE的例子非常常见，是很好的技巧，要铭记。</p>

<h2>Polymorphic Allocator</h2>

<p>allocator这个概念应该还不是很常见，大多数时候这些都有stl内部进行管理，不用担心，但是有些时候，当用户想用自定义的allocator的时候，问题随之而来。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">alloc1</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">alloc2</span><span class="o">&gt;</span> <span class="n">vec2</span><span class="p">;</span>
</span><span class='line'><span class="c1">// oops, vec1 and vec2 now have different types now, which should not happen.</span>
</span></code></pre></td></tr></table></div></figure>


<p>Polymorphic Allocator 也就为了解决这个问题而生。</p>

<h4>Allocator</h4>

<p>一个完备的allocator需要具备一些<a href="http://en.cppreference.com/w/cpp/concept/Allocator">条件</a>，一个最简单的allocator可以仅仅是malloc和free的封装。</p>

<h4>memory_resource</h4>

<p>在Polymorphic Allocator的实现里，根据proposal引入了一个新的虚类<code>memory_resource</code>定义了三个virtual接口:</p>

<ol>
<li>do_allocate();</li>
<li>do_deallocate();</li>
<li>do_is_equal();</li>
</ol>


<h4>polymorphic_allocator</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">polymorphic_allocator</span> <span class="p">{</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个class就是memory_resource的wrapper，给予了一个完备（前边提到）allocator的所有接口。这样让比如<code>list&lt;int, polymorphic_allocator&lt;int&gt;&gt;</code>虽然类型一样却使用可能了不同的allocator（在这里插一句，标准库容器std::vector之类比较于shared_ptr（多态）的实现，shared_ptr将allocator通过actor的方式传进来，不得不说是一种设计上的进步。）</p>

<p>这些接口主要负责两个功能：</p>

<ol>
<li>分配memory</li>
<li>构造对象</li>
</ol>


<p>polymorphic_allocator里存着个memory_resource*，负责真正进行allocator和deallocate，没有指定时默认为get_default_resource();</p>

<p>构造基于uses-allocator construction用::new(…);（placement new）进行构造。比较恶心的是pair 的piecewise construction，感兴趣的自行搜索，我是看都不想多看一眼。</p>

<h4>resource_adaptor</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Alloc</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">__resource_adaptor_imp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">memory_resource</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Alloc</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">using</span> <span class="n">resource_adaptor</span> <span class="o">=</span> <span class="n">__resource_adaptor_imp</span><span class="o">&lt;</span>
</span><span class='line'>    <span class="k">typename</span> <span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">_Alloc</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">rebind_alloc</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个class是对allocator的wrapper，把_Alloc包装成memory_resource，这样resource_adaptor&lt;X&lt;T>>和resource_adaptor&lt;X&lt;U>>就是一种类型了（都是memory_resource）。</p>

<p>所以通常可以这样，resource_adaptor包装allocator，送给polymorphic_allocator使用。</p>

<h4>Global Resource</h4>

<p>在写Global Resource的时候遇到了一个static和inline的<a href="http://stackoverflow.com/questions/185624/static-variables-in-an-inlined-function">问题</a>值得讨论：</p>

<p>在头文件中如果写了static function/variable，那么每个编译单元都会有一个自己的function造成浪费。所以一半生成global resource的方法是inline function返回static variable;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">memory_resource</span><span class="o">*&gt;&amp;</span>
</span><span class='line'><span class="n">__get_default_resource</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">memory_resource</span><span class="o">*&gt;</span>
</span><span class='line'>    <span class="n">_S_default_resource</span><span class="p">(</span><span class="n">new_delete_resource</span><span class="p">());</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">_S_default_resource</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>补充一些关于static的知识：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="o">-&gt;</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//multiple copies</span>
</span><span class='line'><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span> <span class="kt">int</span> <span class="n">A</span><span class="o">::</span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="o">-&gt;</span> <span class="k">struct</span> <span class="n">A</span> <span class="p">{};</span> <span class="kt">int</span> <span class="n">A_a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>第二种纯粹表示生命周期比较长（相当于有个只有自己能访问的全局变量。）</p>

<p>static in class == static in function;</p>

<p>static class/type == static function;</p>

<h4>技巧</h4>

<p>bit manipulation来计算alignment的技巧也非常酷炫，值得学习。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">static</span> <span class="kt">size_t</span> <span class="nf">_S_aligned_size</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">__size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">__alignment</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span> <span class="k">return</span> <span class="p">((</span><span class="n">__size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">__alignment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h1>后记</h1>

<p>感谢tim和john给了个充实的暑假，以后想起来啥在写吧，就这样了:)</p>

<p>（特别鸣谢老婆给的关心与支持，爱你❤️）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[libstdc++ 初窥]]></title>
    <link href="http://fyou.me/blog/2015/03/29/stdlibc-plus-plus/"/>
    <updated>2015-03-29T00:02:53-04:00</updated>
    <id>http://fyou.me/blog/2015/03/29/stdlibc-plus-plus</id>
    <content type="html"><![CDATA[<p>写了两周stdlibc++.纪录点对c++的理解吧.</p>

<h3><a href="http://en.cppreference.com/w/cpp/language/default_constructor">default constructor</a></h3>

<ol>
<li>constructor 是不能被定义在class外的</li>
<li>当constructor被定义为default, compiler 会生成一个implicity declared constructor, calls the default constructors of the bases and of the non-static members of this class.</li>
</ol>


<h3><a href="http://en.cppreference.com/w/cpp/language/copy_constructor">copy constructors</a></h3>

<ol>
<li>当user没有定义copy ctor的时候, compiler 会生成一个implicity declared的版本.</li>
<li>这个implicity的版本在一定情况下会被delete,详情见cppreference.</li>
</ol>


<h3><a href="http://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a></h3>

<p>Substitution failure is not an error - 编译器不会立刻炸,会搜索next</p>

<h3>类型擦除(把原来的类型去掉，换成统一类型,换言之cast)</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char a[10];
</span><span class='line'>void* ap = (void*)a;
</span><span class='line'>int b;
</span><span class='line'>void* bp = (void*)&b;</span></code></pre></td></tr></table></div></figure>


<p>这里就都cast成了void指针。</p>

<p>再来看个Any的例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Any {
</span><span class='line'>public:
</span><span class='line'>  Any() : ptr(nullptr) {}
</span><span class='line'>
</span><span class='line'>  Any(const Any& other) {
</span><span class='line'>      ptr = other.ptr-&gt;Copy();
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  Any& operator=(const Any& other) {
</span><span class='line'>      this-&gt;~Any();
</span><span class='line'>      ptr = other.ptr-&gt;Copy();
</span><span class='line'>      return *this;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  ~Any() {
</span><span class='line'>      if (ptr != nullptr) {
</span><span class='line'>    delete ptr;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  template&lt;typename T&gt;
</span><span class='line'>    void Assign(const T& data) {
</span><span class='line'>  this-&gt;~Any();
</span><span class='line'>  ptr = new Wrapper&lt;T&gt;(data);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>  template&lt;typename T&gt;
</span><span class='line'>    T* Get() {
</span><span class='line'>  auto wrapper = dynamic_cast&lt;Wrapper&lt;T&gt;*&gt;(ptr);
</span><span class='line'>  if (wrapper != nullptr) {
</span><span class='line'>      return &wrapper-&gt;data;
</span><span class='line'>  }
</span><span class='line'>  return nullptr;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>private:
</span><span class='line'>  struct AnyData {
</span><span class='line'>      virtual ~AnyData() { }
</span><span class='line'>
</span><span class='line'>      virtual AnyData* Copy() = 0;
</span><span class='line'>  };
</span><span class='line'>
</span><span class='line'>  template&lt;typename T&gt;
</span><span class='line'>    struct Wrapper : public AnyData {
</span><span class='line'>  Wrapper(const T& data) : data(data) {}
</span><span class='line'>
</span><span class='line'>  AnyData* Copy() override {
</span><span class='line'>      return new Wrapper&lt;T&gt;(data);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  T data;
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>  AnyData* ptr;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>#include &lt;iostream&gt;
</span><span class='line'>
</span><span class='line'>int main() {
</span><span class='line'>    Any a;
</span><span class='line'>    a.Assign&lt;int&gt;(3);
</span><span class='line'>    std::cout &lt;&lt; (a.Get&lt;char&gt;() == nullptr) &lt;&lt; "\n";
</span><span class='line'>    std::cout &lt;&lt; (*a.Get&lt;int&gt;() == 3) &lt;&lt; "\n";
</span><span class='line'>
</span><span class='line'>    Any b;
</span><span class='line'>    b = a;
</span><span class='line'>    std::cout &lt;&lt; (*b.Get&lt;int&gt;() == 3) &lt;&lt; "\n";
</span><span class='line'>
</span><span class='line'>    return 0;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h3>Placement new</h3>

<p>通常的new = malloc + ctor, 所以palcement new 就是在分配好的内存地址上再调用一次ctor</p>

<p>通常的delete = dctor + free</p>

<h3>Vtable 的 C 实现</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>typedef void (*GenericFuncPtr)(void);
</span><span class='line'>//use general ptr array store vf pointer
</span><span class='line'>
</span><span class='line'>struct Cat {
</span><span class='line'>    GenericFuncPtr* vtable_ptr;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>void cat_speak(struct Cat* this) {
</span><span class='line'>    printf("miao");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void cat_die(struct Cat* this) {
</span><span class='line'>    printf("ewww");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>GenericFuncPtr cat_vtable[] = {
</span><span class='line'>    // do in the compile time
</span><span class='line'>    (GenericFuncPtr)cat_speak,
</span><span class='line'>    (GenericFuncPtr)cat_die,
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>void construct_cat(struct Cat* c) {
</span><span class='line'>    c-&gt;vtable_ptr = cat_vtable;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct Lion {
</span><span class='line'>    struct Cat base;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>void lion_speak(struct Lion* this) {
</span><span class='line'>    printf("ow");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void lion_die(struct Lion* this) {
</span><span class='line'>    printf("ahhh");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>GenericFuncPtr lion_vtable[] = {
</span><span class='line'>    (GenericFuncPtr)lion_speak,
</span><span class='line'>    (GenericFuncPtr)lion_die,
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>void construct_lion(struct Lion* l) {
</span><span class='line'>    construct_cat(&l-&gt;base);
</span><span class='line'>    l-&gt;base.vtable_ptr = lion_vtable;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main () {
</span><span class='line'>    struct Lion l;
</span><span class='line'>    struct Cat* c;
</span><span class='line'>    construct_lion(&l);
</span><span class='line'>    c = &l.base;
</span><span class='line'>    // c-&gt;speak
</span><span class='line'>    ((void (*)(struct Lion*))c-&gt;vtable_ptr[0])((struct Lion*)c);
</span><span class='line'>    // c-&gt;die
</span><span class='line'>    ((void (*)(struct Lion*))c-&gt;vtable_ptr[1])((struct Lion*)c);
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3><a href="http://en.cppreference.com/w/cpp/language/partial_specialization">Partial specialization</a></h3>

<p>Partial specialization 只是针对模版参数,而且function不支持partial specialization.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename _Tp&gt; // primary
</span><span class='line'>class A {
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename _Tp&gt;
</span><span class='line'>class A&lt;_Tp[]&gt; {
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename _Tp&gt;
</span><span class='line'>class A&lt;_Tp*&gt; {
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>//template &lt;typename _Tp&gt; //error
</span><span class='line'>//class A&lt;_Tp&gt; {
</span><span class='line'>//};</span></code></pre></td></tr></table></div></figure>


<h3><a href="http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">Universal ref</a></h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template&lt;typename T&gt;
</span><span class='line'>struct A {
</span><span class='line'>    void Foo(T&& /*rvalue ref*/);
</span><span class='line'>};
</span><span class='line'>struct A {
</span><span class='line'>    template&lt;typename T&gt;
</span><span class='line'>      void Foo(T&& /*forwarding ref, or `universal ref`*/);
</span><span class='line'>};
</span><span class='line'>//上面的例子虽然T是模板参数，但不是等着被推出来的。</span></code></pre></td></tr></table></div></figure>


<h3><a href="http://en.cppreference.com/w/cpp/utility/variadic">Variadic functions</a></h3>

<p>用法与用处。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;iostream&gt;
</span><span class='line'>template &lt;typename T&gt;
</span><span class='line'>class A {
</span><span class='line'>public:
</span><span class='line'>  A() { std::cout &lt;&lt; "without size" &lt;&lt; "\n"; }
</span><span class='line'>  A(size_t size) { std::cout &lt;&lt; "with size" &lt;&lt; "\n"; }
</span><span class='line'>  A(size_t size, size_t idx) { std::cout &lt;&lt; "with size, idx" &lt;&lt; "\n"; }
</span><span class='line'>  ~A() { std::cout &lt;&lt; "dtor" &lt;&lt; "\n"; }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>template &lt;typename _Tp, typename... Args&gt;
</span><span class='line'>class B : A&lt;_Tp&gt; {
</span><span class='line'>public:
</span><span class='line'>  //B() { std::cout &lt;&lt; "B ctor" &lt;&lt; "\n"; } B&lt;int&gt;b1 wont work;
</span><span class='line'>  B(Args&&... _args) : A&lt;_Tp&gt;(_args...) { }
</span><span class='line'>private:
</span><span class='line'>  //A&lt;_Tp&gt; _a;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>class Tmp {
</span><span class='line'>public:
</span><span class='line'>  Tmp() { std::cout &lt;&lt; "Tmp ctor" &lt;&lt; "\n"; }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>int main () {
</span><span class='line'>    //B&lt;int&gt; b1;
</span><span class='line'>    B&lt;int,size_t&gt; b2(1);
</span><span class='line'>    //B&lt;int,size_t&gt; b(1,2); //error
</span><span class='line'>    B&lt;int,size_t,size_t&gt; b3(1,2);
</span><span class='line'>
</span><span class='line'>    Tmp tmp;
</span><span class='line'>    Tmp tmp1(); // function !!!!!!!!!!!!
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3><a href="http://stackoverflow.com/questions/6627651/enable-if-method-specialization">function specialization</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试总结]]></title>
    <link href="http://fyou.me/blog/2015/03/01/epic/"/>
    <updated>2015-03-01T15:41:09-05:00</updated>
    <id>http://fyou.me/blog/2015/03/01/epic</id>
    <content type="html"><![CDATA[<h3>Epic</h3>

<p>说来这也算是这辈子第一次tech interview, 总结一下把。总体面试还是分为两块,技术性问题和非技术性问题。</p>

<h3>Non-Tech</h3>

<p>非技术性问题问了目前为止解决的最难的bug是什么, 你最喜欢的游戏是什么，给你一个机会improve，你会怎么improve。</p>

<h3>Tech</h3>

<p>问了Array, List, Tree, Hashtable 各自的优劣,我萌萌的完全不知道该怎么答。回头整理了下发在<a href="https://docs.google.com/spreadsheets/d/1RdcEWxH6dcAfvAEpaDvLp4lW7AwC2C0RNDvXfqlq5yI/edit?usp=sharing">这里</a>,基本从两个角度作答:1.复杂度 2.overhead</p>

<h3>C++</h3>

<ul>
<li>什么是Virtual Destructor: 不用作<a href="https://github.com/Noeyfan/CodingPractice/blob/master/virtual/vf_destructor.cc">owned base class pointer</a>的时候不用.</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">A</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">new</span> <span class="n">B</span><span class="p">();</span>
</span><span class='line'><span class="n">delete</span> <span class="n">p</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>virtual function 是怎么样实现的(一般实现virtual function的时候会把所有的函数指针放到一个<a href="http://en.wikipedia.org/wiki/Virtual_method_table">表(vtable)里</a>,</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="err">一个类有</span><span class="mi">10</span><span class="err">个</span><span class="n">virtual</span> <span class="n">function</span><span class="err">你初始化一个子类对象这个子类对象一般多大？</span>
</span><span class='line'><span class="err">假设基类</span><span class="n">size</span><span class="err">为</span><span class="n">A</span><span class="err">，子类</span><span class="n">size</span><span class="err">为</span><span class="n">B</span><span class="err">假设基类所有成员</span><span class="n">size</span><span class="err">和为</span><span class="n">A</span><span class="err">，</span>
</span><span class='line'><span class="err">子类自己所有成员</span><span class="n">size</span><span class="err">和为</span><span class="n">B</span><span class="err">创建一个子类对象，占多大空间？</span>
</span><span class='line'>
</span><span class='line'><span class="err">答案</span><span class="o">:</span><span class="n">A</span><span class="o">+</span><span class="n">B</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pointer_type</span><span class="p">),</span> <span class="err">另外</span><span class="n">alignment</span><span class="err">可能让他更大</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>几何问题: 做一个2D game, 不用ray cast如何知道A是否看的见B, 很简单, Va*(Pb-Pa) > 0 说明能看得见, 反之看不见。</li>
</ul>


<h3>More</h3>

<p>还是要学好C/C++,<a href="http://www.slideshare.net/olvemaudal/deep-c">deep-C</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于堆分配和栈分配思考以及指针和引用]]></title>
    <link href="http://fyou.me/blog/2014/12/31/heapstack/"/>
    <updated>2014-12-31T01:33:26-05:00</updated>
    <id>http://fyou.me/blog/2014/12/31/heapstack</id>
    <content type="html"><![CDATA[<h4>栈分配</h4>

<p>传统栈分配的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">int</span> <span class="nf">GiveVal</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是合法的栈分配意思是在执行完整个方法后,将里边的数据copy一份,return给外边以后,再将自身的数据a,x释放掉。</p>

<h4>堆分配的产生</h4>

<p>由于栈分配在小规模操作的时候还好,但是上升到大规模的运算时候,拷贝的速度会变的非常的慢。
所以就干脆不释放运算过程中的数据，直接将地址return出来。
传统做法是这样的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">FWidget</span><span class="o">*</span> <span class="nf">CreateWidget</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">FWidget</span><span class="o">*</span> <span class="n">NewWidgetPointer</span> <span class="o">=</span> <span class="n">new</span> <span class="n">FWidget</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">NewWidgetPointer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>引用</h4>

<p>int b = 3;
int&amp; a = b;
这个等价于
int b = 3;
int<em> ap = &b;
a = 4; 等价于 </em>ap = 4;
&amp;a 等价于 ap
唯一不等价的是你没法改ap指向谁
ap只能指向b，不能换人</p>

<h4>例题</h4>

<p>下图方法有什么问题:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">FWidget</span><span class="o">&amp;</span> <span class="n">CreateWidget</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">FWidget</span> <span class="n">NewWidget</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">);</span> <span class="c1">// 栈分配</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">NewWidget</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>等价写法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">FWidget</span><span class="o">*</span> <span class="nf">CreateWidget</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">FWidget</span>  <span class="n">NewWidget</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">&amp;</span><span class="n">NewWidget</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>问题:
return 出去以后原来的东西就被释放了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对于int64, int32的一点理解]]></title>
    <link href="http://fyou.me/blog/2014/12/30/int/"/>
    <updated>2014-12-30T14:34:44-05:00</updated>
    <id>http://fyou.me/blog/2014/12/30/int</id>
    <content type="html"><![CDATA[<h3>基本概念</h3>

<p>32/64 表示的是数字长度</p>

<h4>int32_t 4byte * 8 = 32</h4>

<p>表示范围是: -(2<sup>31</sup>+1) ~ 2<sup>31</sup>-1</p>

<h4>uint32_t</h4>

<p>表示范围是: 0 ~ 2<sup>32</sup>-1</p>

<h4>int64_t 8byte * 8 = 62</h4>

<p>表示范围是: -(2<sup>63</sup>+1) ~ 2<sup>63</sup>-1</p>

<h4>uint64_t</h4>

<p>表示范围是: 0 ~ 2<sup>64</sup>-1</p>

<h3>进制转换</h3>

<p>hex(10) = dec(16)</p>

<h3>编译区别</h3>

<p>cc -m32 a.cc
cc -m64 a.cc</p>

<p>指针大小是不相同的64位下是8byte, 32位下是4byte.</p>

<p>原因:就是说,现代操作系统比较贴心,每个程序运行的时候都给你一个大大的独占的内存条,对于32位系统来说，给的内存条大小为2<sup>32</sup>字节,也就是4GB
对于64位系统来说,给的内存条大小是2<sup>64</sup>字节,也就是数不清的字节
当然不可能真给你这么大。策略是你用多少就给你多少
但是你仿佛有一个超大内存可以独霸
所有的指针都是存的这个超大内存的地址
自然,32位系统的指针是4字节，因为一共有2<sup>32</sup>个格子嘛,4字节就是32位数,每个数对应一个格子,也就是存了32个01.
64位的话只是更多而已,依然是一一对应</p>

<h3>数组与指针后移</h3>

<p>假设T a[] = {};
已知a地址为A
a+1 的地址是&mdash;&ndash;> A + sizeof(T); // 此处是T而不是T*</p>

<h3>补码反码表示</h3>

<p>C中 ^表示异或计算 (不同为1,相同为0)
      ~表示按位取反 (计算机中求负数 = 取反+1)
        如果出现要求返回是uint却返回了负数的情况,计算机会吧他取反+1当成uint来计算。 -8 = ~8 + 1 = 2<sup>32</sup> -1 -8 +1</p>

<h3>关于所谓的符号位</h3>

<pre><code>    举例说明:
    比如一个一字节的数:
    0 ~ 0111 1111是正数,表示0~127
    1000 0000 ~ 1111 1111是负数,表示-128 ~ -1
    每个正数取反加一就是相应的负数
    -128比较诡异,因为没有对应的正数

    也就是说最高位是1表示正,是0表示负这个没错,但是具体求的时候,始终是取反+1
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP Server-Client 实现]]></title>
    <link href="http://fyou.me/blog/2014/11/24/tcp-prectise/"/>
    <updated>2014-11-24T22:22:50-05:00</updated>
    <id>http://fyou.me/blog/2014/11/24/tcp-prectise</id>
    <content type="html"><![CDATA[<p>出于练习目的，决定自己实现一遍client-server的基础模型.
<a href="https://github.com/Noeyfan/crack_code_interview/tree/master/socket">源码</a></p>

<h4>Server端</h4>

<p>1.申明并取得启用服务地址的一系列参数(这里通过命令行输入).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">client</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">connectfd</span><span class="p">,</span> <span class="n">sin_size</span><span class="p">;</span>
</span><span class='line'><span class="n">sin_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span> <span class="c1">//端叙转换,atoi只用于转换数字</span>
</span><span class='line'><span class="c1">//转化时跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(&#39;/0&#39;)才结束转换，并将结果返回。</span>
</span><span class='line'>
</span><span class='line'><span class="n">server</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span><span class='line'><span class="n">server</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
</span><span class='line'><span class="n">server</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span> <span class="c1">//localhost</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.创建socket, 并设置为resuable(并发服务器)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">int</span> <span class="n">socketfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//返回int</span>
</span><span class='line'><span class="kt">int</span> <span class="n">opt</span> <span class="o">=</span> <span class="n">SO_REUSEADDR</span><span class="p">;</span>
</span><span class='line'><span class="n">setsockopt</span><span class="p">(</span><span class="n">socketfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opt</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.bind 和listen</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">socketfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Bind error&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">socketfd</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;listen() error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.accept卡住程序，等待客户连入，一但连入，开thread处理client</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">if</span><span class="p">((</span><span class="n">connectfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">socketfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client</span><span class="p">,</span> <span class="p">(</span><span class="kt">socklen_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sin_size</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">//connectfd is only for process request</span>
</span><span class='line'>  <span class="n">perror</span> <span class="p">(</span><span class="s">&quot;accept() error </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">struct</span> <span class="n">ARG</span><span class="o">*</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ARG</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ARG</span><span class="p">));</span>
</span><span class='line'>  <span class="n">arg</span><span class="o">-&gt;</span><span class="n">connfd</span> <span class="o">=</span> <span class="n">connectfd</span><span class="p">;</span>
</span><span class='line'>  <span class="n">connarr</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">connectfd</span><span class="p">;</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;connect fd after is : %d&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">connfd</span><span class="p">);</span>
</span><span class='line'>  <span class="n">arg</span><span class="o">-&gt;</span><span class="n">client</span> <span class="o">=</span> <span class="n">client</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">start_routine</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">))</span> <span class="p">{</span> <span class="c1">//if get strange thing, most likely is pass parameter</span>
</span><span class='line'>      <span class="n">perror</span><span class="p">(</span><span class="s">&quot;pthread create error&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Client端</h4>

<p>1.载入server参数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server_addr</span><span class="p">;</span>
</span><span class='line'><span class="c1">//两种方法获取server_addr</span>
</span><span class='line'><span class="c1">//1. 可以读取localhost</span>
</span><span class='line'><span class="k">struct</span> <span class="n">hostent</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>
</span><span class='line'><span class="n">server</span> <span class="o">=</span> <span class="n">gethostbyname</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'><span class="n">bcopy</span><span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">h_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">,</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">h_length</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//2. 直接对server_addr放入ipaddr</span>
</span><span class='line'><span class="n">socketaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">);</span> <span class="c1">// 127.0.0.1可以是任何string</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.connect to the Server</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_addr</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">server_addr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;fail to connect&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.开thread去处理服务器发来的信息</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_receive</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">)){</span>
</span><span class='line'>  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;listen create error&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.在另外的while loop里进行发送</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// must</span>
</span><span class='line'>  <span class="n">sendRequest</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</span><span class='line'>  <span class="c1">//在sendRequest里用fegets卡住程序.</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>I/O复用提高效率</h4>

<p>基本概念(从非阻塞轮询到select/poll到epoll)</p>

<p>1.非阻塞轮询:不停检测所有io,有数据则读取</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="n">stream</span><span class="p">[]){</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="n">has</span> <span class="n">data</span><span class="p">){</span>
</span><span class='line'>          <span class="n">read</span> <span class="n">all</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.为了避免cpu空转:引入select代理
同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">select</span><span class="p">(</span><span class="n">stream</span><span class="p">[]);</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="n">stream</span><span class="p">[]){</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="n">has</span> <span class="n">data</span><span class="p">){</span>
</span><span class='line'>          <span class="n">read</span> <span class="n">all</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。</p>

<p>3.epoll (event poll)
epoll会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的,复杂度降低到了O(k)，k为产生I/O事件的流的个数.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">active_stream</span><span class="p">[]</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epollfd</span><span class="p">)</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="n">active_stream</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">read</span> <span class="n">or</span> <span class="n">write</span> <span class="n">till</span> <span class="n">unavailable</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Function Pointer]]></title>
    <link href="http://fyou.me/blog/2014/11/22/p-thread/"/>
    <updated>2014-11-22T16:19:47-05:00</updated>
    <id>http://fyou.me/blog/2014/11/22/p-thread</id>
    <content type="html"><![CDATA[<p>今天才知道各各系统的man是不一样的,mac下查man还是上网查把。</p>

<p>0.前言 <a href="https://github.com/Noeyfan/CodingPractice/blob/master/virtual/virtualFunctionC.c">C实现virtual function</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>函数:
</span><span class='line'>{返回值类型} {函数名}({参数列表})这个格式你应该很熟悉了，就是函数
</span><span class='line'>
</span><span class='line'>函数指针:函数指针也是一种变量，可以直接以函数名赋值
</span><span class='line'>{返回值类型} （*{变量名}）({参数列表})
</span><span class='line'>
</span><span class='line'>变量声明:
</span><span class='line'>{类型} {和表达式很像的东西}</span></code></pre></td></tr></table></div></figure>


<p>1.基础应用(1)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">typedef</span> <span class="nf">float</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)</span> <span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="p">);</span>
</span><span class='line'><span class="c1">//pf 是函数指针类型,注意此处*的位置，表示取值</span>
</span><span class='line'><span class="c1">//typedef 将pf变成一个类型</span>
</span><span class='line'><span class="c1">//如果没有typedef,需要对每个同样函数指针的定义做相同的事情</span>
</span><span class='line'><span class="c1">//float (*pf)(float, float);</span>
</span><span class='line'><span class="c1">//float (*a)(float, float);</span>
</span><span class='line'><span class="c1">//此处变量名也可以省去，方便YY :)</span>
</span><span class='line'>
</span><span class='line'><span class="kt">float</span> <span class="nf">foo</span><span class="p">(</span><span class="n">flaot</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">pf</span> <span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span>
</span><span class='line'>  <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.基础应用(2)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">add</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">imp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">fp</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;result is %i&quot;</span><span class="p">,</span> <span class="n">imp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">add</span><span class="p">));</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.两种定义形式</p>

<ul>
<li>C: 返回类型 (*函数指针名称)(参数类型,参数类型,参数类型，…);</li>
<li>C++: 返回类型 (类名称::*函数成员名称)(参数类型，参数类型，参数类型，…);</li>
</ul>


<p>4.函数指针作为返回值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">(</span><span class="kt">char</span> <span class="n">op</span><span class="p">))(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">add</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">signal</span><span class="p">)(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">int</span><span class="p">))(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="c1">//unix 系统函数</span>
</span><span class='line'><span class="c1">//函数名称signal</span>
</span><span class='line'><span class="c1">//接受两个参数- int 和 一个函数指针</span>
</span><span class='line'><span class="c1">//返回函数指针类型为: void(*)(int)</span>
</span><span class='line'><span class="c1">//照着读signal 调用两次以后返回void</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">returnpf</span><span class="p">)(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// (*returnpf) 这个括号不能少</span>
</span><span class='line'>  <span class="n">returnpf</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;result is %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">returnpf</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
</span><span class='line'>  <span class="c1">//or</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;result is %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">foo</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5.函数指针数组</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">float</span> <span class="p">(</span><span class="o">*</span><span class="n">pFunctionArray</span><span class="p">[</span><span class="mi">10</span><span class="p">])(</span><span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.用typedef 简化函数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="c1">//void (*signal)(int signo,void (*func)(int))(int);</span>
</span><span class='line'><span class="c1">//= pf signal(int signo, pf func);</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="kt">void</span> <span class="nf">pf</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="c1">//void (*signal)(int signo,void (*func)(int))(int);</span>
</span><span class='line'><span class="c1">// = pf* signal(int signo, pf* func);</span>
</span></code></pre></td></tr></table></div></figure>


<p>7.附言，米米的教导 <a href="http://www.zhihu.com/question/20635559/answer/19669437">米米知乎解答</a></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">signal</span><span class="p">[</span><span class="mi">4</span><span class="p">])(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">char</span><span class="p">)[</span><span class="mi">6</span><span class="p">];</span>
</span><span class='line'><span class="c1">//变量申明</span>
</span><span class='line'><span class="c1">//该表达式返回int</span>
</span><span class='line'><span class="c1">//所以(*signal[4])(int)(char)返回一个int指针(可以用作[6])</span>
</span><span class='line'><span class="c1">//(*signal[4])(int)是一个函数指针，接受参数char，返回int指针</span>
</span><span class='line'><span class="c1">//signal[4]是一个函数指针，接受int，返回另一个函数指针，后者的函数类型如上所述，“接受char，返回int指针”</span>
</span><span class='line'><span class="c1">//现在signal是啥呢，肯定是个数组。什么数组呢？上一条那玩意的数组</span>
</span><span class='line'><span class="c1">//结论:signal是一个函数指针数组，函数指针的函数类型为：接受int，返回另一个函数指针，后者的函数类型为“接受char，返回int指针”</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Github Notes]]></title>
    <link href="http://fyou.me/blog/2014/10/16/githubnotes/"/>
    <updated>2014-10-16T17:00:06-04:00</updated>
    <id>http://fyou.me/blog/2014/10/16/githubnotes</id>
    <content type="html"><![CDATA[<h3>Normal Usage</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git reset --hard 加上要回滚到的那个hash tag
</span><span class='line'>
</span><span class='line'>git init 
</span><span class='line'>
</span><span class='line'>git status
</span><span class='line'>
</span><span class='line'>git add filename
</span><span class='line'>
</span><span class='line'>git add '\*.name'
</span><span class='line'>
</span><span class='line'>git log 
</span><span class='line'>
</span><span class='line'>git remote add origin https://github.com/try-git/try\_git.git
</span><span class='line'>
</span><span class='line'>git push -u origin master  记得加上remote name(origin) 和branch name(master)
</span><span class='line'>
</span><span class='line'>git pull  origin master 
</span><span class='line'>
</span><span class='line'>git diff HEAD
</span><span class='line'>
</span><span class='line'>git add octofamily/octodog.txt
</span><span class='line'>
</span><span class='line'>git diff --staged
</span><span class='line'>
</span><span class='line'>git reset octofamily/octodog.txt 但是文件还会存在
</span><span class='line'>
</span><span class='line'>git checkout -- octocat.txt 回到octocat的last commit时候
</span><span class='line'>
</span><span class='line'>git checkout -- octocat.txt 新建clean up branch , 且同时switch to it
</span><span class='line'>
</span><span class='line'>git branch 
</span><span class='line'>
</span><span class='line'>git rm '\*.txt'
</span><span class='line'>
</span><span class='line'>git commit -m ""
</span><span class='line'>
</span><span class='line'>git checkout master
</span><span class='line'>
</span><span class='line'>git merge clean\_up
</span><span class='line'>
</span><span class='line'>git branch -d clean\_up
</span><span class='line'>
</span><span class='line'>git push</span></code></pre></td></tr></table></div></figure>


<h3>Bvw Learn</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -f  清除所有untrack的文件
</span><span class='line'>
</span><span class='line'>git add -u 添加所有改动文件
</span><span class='line'>
</span><span class='line'>git checkout -- &lt;filename&gt; 解除单个文件的改动
</span><span class='line'>
</span><span class='line'>git reset 取消add变回untracked file
</span></code></pre></td></tr></table></div></figure>


<h3>Stash</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git status 查看那些改动
</span><span class='line'>
</span><span class='line'>git stash 将所有改动放进stash
</span><span class='line'>
</span><span class='line'>git stash list 看stash里的东西
</span><span class='line'>
</span><span class='line'>git checkout -b &lt;branch name&gt; 创建新branch
</span><span class='line'>
</span><span class='line'>git stash apply 将所有改动放进去
</span><span class='line'>
</span><span class='line'>//在branch 里修改以后回到master进行merge
</span><span class='line'>
</span><span class='line'>git checkout master
</span><span class='line'>
</span><span class='line'>git merge &lt;branch name&gt;
</span><span class='line'>
</span><span class='line'>git branch -d &lt;branch name&gt;</span></code></pre></td></tr></table></div></figure>


<h3>More</h3>

<p><a href="https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line/">Add project to github using command line</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Midterm]]></title>
    <link href="http://fyou.me/blog/2014/10/13/midterm/"/>
    <updated>2014-10-13T13:14:52-04:00</updated>
    <id>http://fyou.me/blog/2014/10/13/midterm</id>
    <content type="html"><![CDATA[<p>一不小心学期就已经过半了，这几天特别的闲反而却莫名的恐惧了起来。从round 0 什么都不会做出来的飞机到round 3独立完成了类似找茬的游戏，时间快的像是高速公路,却又突然被踩住了刹车。经常吐槽遇到了一些不靠谱的队友，回头再看看的时候却又庆幸遇到了这一些可爱的人。</p>

<p>之前博客坏了，一直心情很烦躁感慨很多觉得如果写下来几天几夜也会写不完，结果费劲千辛万苦修好了博客打开新post却又瞬间无话可说。我一直是这么纠结蛋疼三分钟热度的人却一直自诩很能坚持。其实我只是习惯被目标奴役，一旦没事可做的时候就原形毕露。能写两个傻逼Unity小游戏就以为自己了不起了，正好被过来玩的米米又打击一番。颤颤巍巍的打开<em>cc</em>，发现好不容易暑假前弄了点基础又全忘光光了。</p>

<p>在大家都在忙期中考试的时候我难得的在悠闲的码博客，其实也没什么事情要说，就是觉得该写点什么了，至于写的是什么我也不清楚。觉得自己最近脑洞开的太大，不仅思维发散了，灵魂也发散了。记得原来爷爷炫耀他当年枪毙犯人的时候，一枪开过去，犯人应声倒地。通常是真死了，也不乏有个别走火且演技特别好的。爷爷怕他们没死绝，就上去用刀在他们脑子里搅一搅。最近想出了攒钱买车的主义然后天天送外卖，我觉得自己挺天才，但同时觉得自己的脑子也该搅一搅了。</p>

<p>晚上躺床上突然想到了这学期就只剩下两个round了，结束以后大家就会到自己的小房间去了。感觉原来是一大块披萨可以随便吃，结果几刀下去就变成一块一块的了. 我是共产主义党员，对这种事总是特别悲观。3周时间的BVW仿佛每个人都进入了慢动作，慢速不是休假，我喜欢手起刀落的利落，这对我更像一种折磨。</p>

<p>记录两个还能记得的傻逼问题:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>* 用swap完成洗牌
</span><span class='line'>* 遇到SSL Error When installing rubygems, Unable to pull data from 'https://rubygems.org/ ..... error时候记得要用sudo</span></code></pre></td></tr></table></div></figure>


<p>嗯，就这么多了。</p>

<h2>End</h2>

<p><img src="http://fyou.me/images/Pitt_img.JPG" alt="Ops" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello.World]]></title>
    <link href="http://fyou.me/blog/2014/10/11/hello/"/>
    <updated>2014-10-11T15:12:24-04:00</updated>
    <id>http://fyou.me/blog/2014/10/11/hello</id>
    <content type="html"><![CDATA[<p>之前电脑坏了，博客没有备份。重新写又懒得弄，现在摘取点重点</p>

<ul>
<li>去掉disqus内置<strong>comments</strong>字样,在&#8217;source/_layouts&#8217;下</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!--&lt;h1 class="title"&gt;Comments&lt;/h1&gt;--&gt;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>BVW Round0 的笔记</li>
</ul>


<p>被设置为trigger的collider是不会有物理碰撞效果的。</p>

<p>Debug.Log(GameObject.name); 常用Debug</p>

<p>Object 之间通过sendMessage来启用别人script里的方法</p>

<p>Time.realtimeSince… 会keep recording， 而Time.timeSinceLeveLoad 只会更新本level的时间</p>

<p>注意拖拽进来的位置要reset</p>

<ul>
<li>还有谷歌CEO的coroutine教程：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>每开一个coroutine，就相当于多开了一个main
</span><span class='line'>那句yield waitforseconds你可以看成简单的“延时若干秒，然后继续执行”
</span><span class='line'>你操作系统宗平教的？
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>IEnumerator Occur_rocks()
</span><span class='line'>这个就是coroutine？
</span><span class='line'>恩，老宗上课太甩了
</span><span class='line'>他老喜欢拟人。。不讲术语，，
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>对，每调用一次这个函数返回一个新的coroutine
</span><span class='line'>每调用一次就多开一个main的感觉
</span><span class='line'>这个返回值被unity拿去用了，怎么用你暂时可以不用管
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>那我为啥还得写while才能不停调用
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>这个返回值你可以看成一个coroutine对象，我假象这个对象有close方法，可以用来关闭coroutine等等
</span><span class='line'>因为你这个coroutine要不断的跑啊，不断生成rocks
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>也就是说返回值我不用管
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>注意coroutine里没有return
</span><span class='line'>嗯，coroutine的返回值是c#帮你搞定的，不是你return的
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>也就是我要开多个IEnumerator才能实现各种包裹的分离
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>嗯
</span><span class='line'>那样也比较清楚
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>yield 就直接当成刻个让他等待的方法用么
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>嗯
</span><span class='line'>yield本身不是。那个wait for才是
</span><span class='line'>yield也有别的用法
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>yield 是那个什么相当于代码块的占位符
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>啥？
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>还是哥哥语言yield 都不一样
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>各个语言yield是一个意思。你想知道是什么意思么？
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>ruby 有yield 就表示占空，然后别的地方代码块可以塞到yield那里执行
</span><span class='line'>恩
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>coroutine和函数不一样。普通函数return之后函数执行就结束了
</span><span class='line'>coroutine的yield后面和return一样，应该跟上一个“返回值”，这个返回值可以供调用者（unity）使用，但是coroutine没有结束，只是被挂在那，不会继续执行
</span><span class='line'>直到unity下次再次调用该coroutine（仿佛调用一个函数一样），该coroutine会从上次yield的那个地方继续执行，仿佛没有中断过
</span><span class='line'>所以coroutine外面（unity）用起来和函数一样，里面是一段代码连续不断在跑。
</span><span class='line'>你说的ruby里其实一回事，yield出一个东西，给外面的block用
</span><span class='line'>若yield nothing，只不过和return nothing类似罢了
</span><span class='line'>所以coroutine刚刚说多线程其实不对，代码执行的顺序是：执行外面代码，某处调用coroutine，跳到coroutine代码，某处yield，跳回外面从调用处继续，某处外面再调用该coroutine，跳进coroutine代码的yield处继续，这样循环。
</span><span class='line'>两片代码都是连续执行，但是来回跳
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>unity的main方法在哪，它每个script不就是创建了个class嘛
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>Main
</span><span class='line'>被藏起来了
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>图形化界面的物体发生事件的时候，他回生成这个class的一个实例并执行那些方法？
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>嗯
</span><span class='line'>基本是on开头的方法
</span><span class='line'>都是unity规定好的
</span><span class='line'>我觉得class的实例是在初始化的时候就生成了
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>回到coroutine，一步一步执行，到yield，return 了一个new WaitSecond
</span><span class='line'>这WaitSecond是方法么
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>new啊
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>它执行了wait几秒这个动作
</span><span class='line'>？
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>new后面自然是个类
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>类？就是Class？
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>所以yield出去一个WaitSecond类的实例
</span><span class='line'>这个实例包含一个数字，表示要睡的秒数
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>然后就跳到WaitSecond执行？
</span><span class='line'>完了再跳回来？
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>new的时候跑去执行wait second的构造函数
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>那和直接的方法调用区别在哪
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>这不是new嘛
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>soga
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>new出来一个对象并yield出去
</span><span class='line'>unity看到一个wait second对象
</span><span class='line'>然后会执行wait的动作
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>那不能直接写new 然后再写个调用嘛
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>关键是怎么让这个coroutine wait
</span><span class='line'>
</span><span class='line'>* Fan You
</span><span class='line'>
</span><span class='line'>soga
</span><span class='line'>
</span><span class='line'>* Tim Shen
</span><span class='line'>
</span><span class='line'>unity肯定跑着一个调度器
</span><span class='line'>那个调度器负责谁在什么时候执行
</span><span class='line'>unity也是要告诉那个调度器，让某某coroutine休息一段时间
</span><span class='line'>如果coroutine自己有这个调度器，那也能自己休息自己
</span><span class='line'>但是调度器还是不要暴露给程序员的好
</span><span class='line'>我估计那个调度器是c#自带的，还不是unity的
</span></code></pre></td></tr></table></div></figure>


<h2>End</h2>

<p>顺便贴个Markdown的<a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">doc</a>链接.</p>
]]></content>
  </entry>
  
</feed>
